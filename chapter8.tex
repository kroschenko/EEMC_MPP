% Электронный учебник будет представлять собой один файл в формате pdf.
% Для того, чтобы создать этот
% файл, нужно поработать с настоящим документом, который в дальнейшем будем называть
% <<рабочий файл>>. Прежде, чем приступать к работе, прочтите внимательно первые две части
% <<Руководства пользователю>>. По большому счету электронное издание <<Руководство
% пользователю>> показывает стиль и
% структуру создаваемого электронного учебника (стиль и структуру, конечно же, можно будет
% поменять по Вашему усмотрению). Основную часть экрана занимает так называемая рабочая
% область -- здесь будет представлена информация учебника, предназначенная для изучения
% студентами. Правая часть -- интерактивная панель, предназначенная для удобной навигации
% по документу.

% Теперь можно приступать к работе. Внимательно читайте все комментарии (они начинаются после
% символа %).
% Если Вы что-нибудь поменяли, то для того, чтобы увидеть результат,
% нужно скомпилировать рабочий файл в pdf-документ (см. <<Руководство пользователю>>).

%---------------------------------------------------------------------------------------------------------------

\documentclass[12pt, a4paper]{book}% Эту команду не стоит менять
\usepackage{xspace,colortbl}% Эту команду не стоит менять
\usepackage[utf8]{inputenc}% Эту команду не стоит менять
\usepackage[english,russian]{babel}% Эту команду не стоит менять
\usepackage{euscript,latexsym,amsfonts,amsthm,amsmath,amssymb}% Эту команду не стоит менять
\usepackage[pdftex,hypertex]{hyperref}% Эту команду не стоит менять
\usepackage{color}% Эту команду не стоит менять
\usepackage[screen,panelright,sectionbreak]{pdfscreen}% Эту команду не стоит менять
\graphicspath{{images/}{images/amblems/}{images/fon/}{images/panel/}{images/pic/}}% Эту
% команду не стоит менять. Она указывает путь к папкам, в которых хранятся графические файлы
 \margins{.25in}{.25in}{.25in}{.30in}% Эту команду не стоит менять
 \screensize{6.25in}{8in}% Эту команду не стоит менять
  \changeoverlay% Эту команду не стоит менять
\usepackage{longtable}% Эту команду не стоит менять

\usepackage{regexpatch}
\usepackage{listings}
\definecolor{keyword}{RGB}{0,0,150}
\definecolor{identifier}{RGB}{0,0,0}
\definecolor{comment}{RGB}{128,128,128}
\definecolor{string}{RGB}{0,128,0}
\definecolor{numbers}{RGB}{128,128,128}
\lstdefinestyle{customjava}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=java,
  numbers=left,
  showstringspaces=false,
  basicstyle=\small\ttfamily,
  numberstyle=\color{numbers},
  keywordstyle=\bfseries\color{keyword},
  commentstyle=\itshape\color{comment},
  identifierstyle=\color{identifier},
  stringstyle=\color{string},
}
\lstset{escapechar=@,style=customjava}
\makeatletter
\xpatchcmd*\@Overlay@Hook{\put(\strip@pt\@tempdima,\strip@pt\@tempdima)}
{\put(\strip@pt\@tempdima,\strip@pt\dimexpr.5\paperheight)}{}{}
\makeatother

%--------------------------------------------------------------------------------------------

 \paneloverlay{but3.png}% Аргумент этой команды, записанный в фигурных скобках, можно
% изменить. <<{but3.png}>> -- это имя графического файла, который используется в качестве
% фона интерактивной панели. Здесь можно прописать имя любого рисунка в формате png или pdf,
% который Вы хотите использовать в качестве фона для интерактивной панели. Файл
% этого рисунка должен находиться в папке Images/Panel.

%---------------------------------------------------------------------------------------------------

\overlay{m1.png} % Аргумент этой команды, записанный в фигурных скобках, можно
% изменить. <<{m8.png}>> -- это имя графического файла, который используется в качестве
% фона основой рабочей области. Здесь можно прописать имя любого рисунка в формате
% png или pdf, который Вы хотите использовать в качестве фона для основной рабочей области.
% Файл этого рисунка должен находиться в папке Images/fon.

%---------------------------------------------------------------------------------------------

\def\panel{\begin{minipage}[t][\paperheight][t]{\panelwidth}% Эту команду не стоит менять
\centering\null\vspace*{12pt}% Эту команду не стоит менять
 \par\vspace{0.3cm}% Эту команду не стоит менять

%---------------------------------------------------------------------------------------------

\includegraphics[width=2.54cm]{favicon_ru_RU.png}\par\vspace{0.6cm}% Эта команда позволяет вставить
% любую картинку в качестве эмблемы в верхней части интерактивной панели. Аргумент команды
% в квадратных скобках <<[width=2.54cm]>> задает ширину эмблемы (в сантиметрах),
% а аргумент команды в фигурных скобках <<{univ.png}>> -- это имя графического файла,
% содержащего саму эмблему. Здесь можно прописать имя любого рисунка в формате
% png или pdf, который Вы хотите использовать в качестве эмблемы.
% Файл этого рисунка должен находиться в папке Images/amblems
\vspace{0mm}% Эта команда задает расстояние (в миллиметрах) до следующей после эмблемы строки
{\LARGE\itshape Кафедра}% Эту команду лучше не менять

{\large\itshape ИИ}% Впишите сюда название Вашей кафедры

\vspace{5mm}% Эта команда задает расстояние (в миллиметрах) до первой кнопки
% интерактивной панели
%---------------------------------------------------------------------------------------------------

 \Acrobatmenu{FirstPage}{\addButton{1.05in}{\FBlack\@Начало}}\par\vspace{3mm} % Эта команда создает
% кнопку <<Начало>> на интерактивной панели. Нажатие этой кнопки возвращает пользователя
% на первую (титульную) страницу электронного учебника. Аргумент команды <<{\FBlack\@Начало}>>
% можно поменять (например, написать вместо <<Начало>> <<Пачатак>> или <<Титульная страница>>).

%------------------------------------------------------------------------------------------------

\hyperref[oglo]{{\addButton{1.05in}{\@Содержание}}}\par\vspace{3mm} %Эта команда создает
% кнопку <<Содержание>> на интерактивной панели. Нажатие этой кнопки возвращает пользователя
% на первую страницу раздела <<Содержание>> электронного учебника.
% Аргумент команды <<{\@Содержание}>> можно поменять (например, написать
% вместо <<Содержание>> <<Змест>> или <<Оглавление>>).

%---------------------------------------------------------------------------------------------

\hyperref[mybutton]{\addButton{1.05in}{\@Ваша кнопка}}\par\vspace{3mm}%Эта команда создает
% кнопку <<Ваша кнопка>> на интерактивной панели. Нажатие этой кнопки вернет пользователя
% на ту страницу электронного учебника, на которую Вы захотите. Для этого нужно в определенное
% Вами место любого раздела электронного учебника поставить метку \label{mybutton} (подробнее
% о метках можно прочитать в <<Руководстве пользователю>>). Обратите внимание, что имя этой
% метки должно совпасть с аргументом команды, записанном
% в квадратных скобках (\hyperref[mybutton]).
% Аргумент команды <<{\@Ваша кнопка}>> нужно поменять (написать
% вместо <<Ваша кнопка>> любой текст, указывающий пользователю, какую информацию он
% получит, нажав на эту кнопку). Такого типа кнопки удобно создавать для быстрого
% доступа пользователя к некоторой информации электронного учебника (например, справочной
% информации, перечню формул, и т.д.). При желании таких кнопок можно создать несколько
% (сколько позволит высота Интерактивной панели). Для этого нужно соответствующее
% число раз скопировать и вставить сразу после этого комментария
% команду \hyperref[imyametki]{\addButton{1.05in}{\@Ваша кнопка}}\par\vfill
% Если же Вы не хотите создавать ни одной своей кнопки, удалите всю строку, содержащую
% описываемую здесь команду и весь текст данного комментария.

%--------------------------------------------------------------------------------------------

\Acrobatmenu{PrevPage}{\addButton{.51in}% Не меняйте эту команду. Она создает кнопку перехода
{\FBlack\scalebox{.8}[1.4]{\btl}}}\hspace{1pt}% на одну страницу назад
\Acrobatmenu{NextPage}{\addButton{.51in}% Не меняйте эту команду. Она создает кнопку перехода
{\LBlack\scalebox{.8}[1.4]{\rtl}}}\par\vspace{3mm}% на одну страницу вперед

%---------------------------------------------------------------------------------------------

\Acrobatmenu{FirstPage}{\addButton{.51in}% Не меняйте эту команду. Она создает кнопку быстрого
{\FBlack\scalebox{.8}[1.4]{\btl\btl}}}\hspace{1pt}% перехода на первую страницу
\Acrobatmenu{LastPage}{\addButton{.51in}% Не меняйте эту команду. Она создает кнопку быстрого
{\LBlack\scalebox{.8}[1.4]{\rtl\rtl}}}\par\vspace{3mm}% перехода на последнюю страницу

%---------------------------------------------------------------------------------------------

\Acrobatmenu{GoToPage}{\addButton{1.05in}% Не меняйте эту команду. Она создает кнопку,
{\@Страница~\thepage~\@из~\pageref*{pages_total}}}\par\vspace{3mm}% позволяющую совершать
% переход на любую страницу электронного учебника

%---------------------------------------------------------------------------------------------

\Acrobatmenu{GoBack}{\addButton{1.05in} {\@Назад}}\par\vspace{3mm}% Не меняйте эту команду. Она
% создает удобную кнопку возврата к той странице электронного учебника, с которой был совершен
% переход по любой гиперссылке текста учебника или по некоторой кнопке Интерактивной панели.
% Аргумент команды <<{\@Назад}>> можно поменять (например написать вместо <<Назад>>
% <<Обратно>> или <<Возврат>>).

%---------------------------------------------------------------------------------------------------

\Acrobatmenu{FullScreen}{\addButton{1.05in}{\@На весь экран}}\par\vspace{3mm}% Эту команду лучше
% не менять. Она создает кнопку, позволяющую <<развернуть>> электронный учебник на весь экран.
% Аргумент команды <<{\@На весь экран}>> можно поменять (например написать вместо
% <<На весь экран>> <<Развернуть>> или <<Увеличить>>)

%---------------------------------------------------------------------------------------------

\Acrobatmenu{Quit}{\addButton{1.05in}{\@Закрыть}}\par\vspace{3mm}% Эту команду лучше
% не менять. Она создает кнопку, нажатие которой закрывает электронный учебник. Аргумент
% команды <<{\@Закрыть}>> можно поменять (например написать вместо
% <<Закрыть>> <<Выход>> или <<Уйти>>)

%---------------------------------------------------------------------------------------------

\end{minipage}}% Эту команду не стоит менять

\definecolor{panelbackground}{gray}{.8}% Эту команду не стоит менять
  \definecolor{buttonbackground}{gray}{.9}% Эту команду не стоит менять
  \definecolor{buttonshadow}{gray}{.2}% Эту команду не стоит менять
  \definecolor{orange}{rgb}{1,.549,0}% Эту команду не стоит менять
  \definecolor{orange1}{rgb}{1,.5,0}% Эту команду не стоит менять
  \definecolor{section0}{rgb}{0,.5,.1}% Эту команду не стоит менять
  \definecolor{section1}{rgb}{0,.5,1}% Эту команду не стоит менять
  \definecolor{section2}{rgb}{0,.5,.5}% Эту команду не стоит менять
  \definecolor{section3}{rgb}{0,.5,.4}% Эту команду не стоит менять
  \definecolor{section4}{rgb}{.4,.5,.2}% Эту команду не стоит менять
  \definecolor{section5}{rgb}{.5,.5,.3}% Эту команду не стоит менять
\newcommand{\esup}{\mathop{\rm ess\:sup\;}_{t>0\;\,}}% Эту команду не стоит менять
\newcommand{\res}{\mathop{\rm res}}% Эту команду не стоит менять
\renewcommand{\Re}{{\rm Re}}% Эту команду не стоит менять
\renewcommand{\Im}{\operatorname{Im}}% Эту команду не стоит менять
\newcommand{\norm}[1]{\left\Vert#1\right\Vert}% Эту команду не стоит менять
\newcommand{\set}[1]{\left\{#1\right\}}% Эту команду не стоит менять
\newcommand{\h}{{\mathcal H}}% Эту команду не стоит менять
\newcommand{\nur}{\EuScript{L}_{\nu,r}}% Эту команду не стоит менять
\newcommand{\nutwo}{\EuScript{L}_{\nu,2}}% Эту команду не стоит менять
\newcommand{\eqdef}{\stackrel{\rm def}{=}}% Эту команду не стоит менять
\renewcommand{\thesection}{\arabic{chapter}.\arabic{section}\hspace{-4mm}}% Эти команды не стоит менять
\renewcommand{\thesubsection}{\arabic{chapter}.\arabic{section}.% Эту команду не стоит менять
\arabic{subsection}\hspace{-4mm}}% Эту команду не стоит менять
\renewcommand{\theequation}{\arabic{chapter}.\arabic{equation}}% Эту команду не стоит менять
\makeatletter% Эту команду не стоит менять
\newcommand*\l@struct{\@dottedtocline{1}{0em}{2.3em}}% Эту команду не стоит менять
\newcommand{\l@abcd}[2]{\rightskip=\@pnumwidth\leftskip=% Эту команду не стоит менять
\@tempdima\hspace{-2.7em}\noindent #1\hfill% Эту команду не стоит менять
\rlap{\makebox[\@pnumwidth][r]{\bf#2}}}% Эту команду не стоит менять
\renewcommand*\l@section{\@dottedtocline{1}{1.5em}{2.2em}}% Эту команду не стоит менять
\renewcommand*\l@subsection{\@dottedtocline{2}{3.8em}{3.0em}}% Эту команду не стоит менять
\renewcommand{\section}{\@startsection{section}{1}{1pt}% Эту команду не стоит менять
{4.0ex plus -0.2ex minus -0.2ex}{2.0ex plus 0.2ex}{\centering\bf}}% Эту команду не стоит менять
\renewcommand{\subsection}{\@startsection{subsection}{2}% Эту команду не стоит менять
{23pt}{3.5ex plus -0.2ex minus -0.2ex}{1ex plus 0.2ex}{\bf}}% Эту команду не стоит менять
\renewcommand{\chapter}{\vspace{8mm}\global\@topnum=0% Эту команду не стоит менять
\@afterindenttrue\secdef\@chapter\@schapter}% Эту команду не стоит менять
\renewcommand{\@makechapterhead}[1]{{\parindent=0pt\raggedright% Эту команду не стоит менять
\bf ЛЕКЦИЯ { }\centering\Large\thechapter\vspace{0.1mm}~\centering% здесь можно заменить
% слово <<ЛЕКЦИЯ>> на любое другое

\large\bf #1\par\nopagebreak\vspace{4mm}}}% Эту команду не стоит менять

\renewcommand{\tableofcontents}{\section*{\contentsname}\@starttoc{toc}}% Эту команду не
% стоит менять

%--------------------------------------------------------------------------------------------

% Следующие команды задают вид и структуру раздела <<Содержание>> (этот раздел
% генерируется автоматически).
\def\@chapter[#1]#2{\ifnum \c@secnumdepth >\m@ne% Эту команду не стоит менять
\if@mainmatter% Эту команду не стоит менять
\refstepcounter{chapter}% Эту команду не стоит менять
\typeout{\@chapapp\space\thechapter.}% Эту команду не стоит менять
\addcontentsline{toc}{chapter}% Эту команду не стоит менять
{{\rm Лекция \,\thechapter}\ \ #1}% Здесь можно заменить слово <<Лекция>> на любое другое
\else% Эту команду не стоит менять
\addcontentsline{toc}{chapter}{#1}% Эту команду не стоит менять
\fi% Эту команду не стоит менять
\else% Эту команду не стоит менять
\addcontentsline{toc}{chapter}{#1}% Эту команду не стоит менять
\fi% Эту команду не стоит менять
\chaptermark{#1}% Эту команду не стоит менять
\addtocontents{lof}{\protect\addvspace{10\p@}}% Эту команду не стоит менять
\addtocontents{lot}{\protect\addvspace{10\p@}}% Эту команду не стоит менять
\if@twocolumn% Эту команду не стоит менять
\@topnewpage[\@makechapterhead{#2}]% Эту команду не стоит менять
\else% Эту команду не стоит менять
\@makechapterhead{#2}% Эту команду не стоит менять
\@afterheading% Эту команду не стоит менять
\fi}% Эту команду не стоит менять

\makeatother% Эту команду не стоит менять

%--------------------------------------------------------------------------------------------

% Следующие команды определяют имена окружений типа <<Теорема>> (см. <<Руководство
% пользователю>>).
% Аргумент команды \newtheorem, записанный в фигурных скобках -- это имя окружения,
% которое будет использоваться при записи команды, создающей соответствующее окружение
% в тексте электронного учебника, а поэтому оно должно состоять из латинских символов;
% команда \color{red} задает цвет надписи имени окружения на русском языке
% (доступные цвета: red (красный), gray (серый), orange (оранжевый), blue (голубой),
% green (зеленый) и т.д).
% Можно создавать свои собственные окружения такого типа. Например, команда
% \newtheorem{mymicl}{\indent \color{red}Моя мысль}[chapter] создаст окружение
% типа <<Теорема>> с именем <<Моя мысль>>.
\newtheorem{theorem}{\indent \color{red}Теорема}[chapter]
\newtheorem{lemma}{\indent \color{red}Лемма}[chapter]
\newtheorem{corollary}{\indent \color{red}Следствие}[chapter]
\newtheorem{note}{\indent \color{red}Замечание}[chapter]
\newtheorem{opr}{\indent \color{red}Определение}[chapter]
\newtheorem{example}{\indent \color{red}Пример}[chapter]
\newtheorem{utv}{\indent \color{red}Утверждение}[chapter]
\newtheorem{gip}{\indent \color{red}Гипотеза}[chapter]

%--------------------------------------------------------------------------------------------

\pagestyle{empty}% Эту команду не стоит менять



% Теперь вся подготовительная работа проведена, стиль и структура электронного
% учебника заданы. Дальше можно начинать наполнение электронного учебника.

% -----------------------------------------------------------------------------------------

\begin{document}\large% Эту команду не стоит менять
% Приступим к созданию титульной страницы. Далее можно менять все, что написано
% на русском языке. Но не забывайте читать комментарии.
\begin{center}% Эту команду не стоит менять. Она <<центрирует>> текст, заключенный между
% командами \begin{center} и \end{center}, по ширине экрана.
  УЧРЕЖДЕНИЕ ОБРАЗОВАНИЯ\\
  <<Брестский государственный технический университет>>
\end{center}% Эта команда завершает <<центрирование>> текста
\vspace{20mm}% Эта команда увеличивает расстояние между строками (расстояние указано
% в фигурных скобках в миллиметрах).
\begin{center}% Эту команду не стоит менять. Она <<центрирует>> текст, заключенный между
% командами \begin{center} и \end{center}, по ширине экрана.
\textbf{% Эта команда задает полужирный шрифт текста, являющегося аргументом
% команды (т.е. текста, заключенного в фигурные скобки)
     {\LARGE \color{red} СИСТЕМНОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ}\\[10mm]% Переход на следующую строку
% задан командой \\, а в квадратных скобках указано расстояние
% до следующей строки текста (в миллиметрах).
    \\[10mm]% Переход на следующую строку задан командой \\,
% а в квадратных скобках указано расстояние до следующей строки текста (в миллиметрах).
    {\it\Large Электронный учебно-методический комплекс }\\% Переход на следующую строку
% задан командой \\
    {\it\Large для студентов факультета электронно-информационных систем}% Любую из строк такого вида можно
% при желании удалить или добавить новую с произвольным текстом.
}
\end{center}% Эта команда завершает <<центрирование>> текста
\vspace{30mm}% Эта команда увеличивает расстояние между строками (расстояние указано
% в фигурных скобках в миллиметрах).
\begin{center}% Эту команду не стоит менять. Она центрирует текст, заключенный между
% командами \begin{center} и \end{center}, по ширине экрана.
Брест\\% Переход на следующую строку задан командой \\
БрГТУ\\% Переход на следующую строку задан командой \\
  2023% Здесь указывается год создания электронного учебника
\end{center}% Эта команда завершает <<центрирование>> текста

% --------------------------------------------------------------------------------------------

\newpage% Эта команда задает переход на новую страницу (разрыв страницы).

% На этой странице будет размещена информация об авторах, рецензентах, экспертах и т.д.
% Прежде, чем приступать к работе с этой страницей,
% прочитайте часть 3 <<Руководства пользователю>>.

 \overlay{m1.png}% Эта команда задает новый фон рабочей области. Аргумент этой команды,
% записанный в фигурных скобках, можно  изменить. <<{m1.png}>> -- это имя графического
% файла, который используется в качестве фона основой рабочей области. Здесь можно
% прописать имя любого рисунка в формате png или pdf, который Вы хотите использовать
% в качестве фона для основной рабочей области.
% Файл этого рисунка должен находиться в папке Images/fon.

{\large% Эта команда задает шрифт определенного размера (см. <<Руководство пользователю>>)
\begin{flushleft}% Эту команду не стоит менять. Она выравнивает по левому краю текст,
% заключенный между командами \begin{flushleft} и \end{flushleft}.
 {\bf\color{red} Авторы:}% Здесь можно прописать любой текст (например, заменить слово
% <<Авторы>> на <<Авторы-составители>>

% Ниже команды \bf задают полужирный шрифт текста в группе, заключенной в фигурные скобки

~~~~{\bf Фамилия Имя Отчество} -- должность


~~~~{\bf Фамилия Имя Отчество} -- должность

~~~~{\bf Фамилия Имя Отчество} -- должность

~~~~{\bf Фамилия Имя Отчество} -- должность


\vspace{10mm}% Эта команда увеличивает расстояние между строками (расстояние указано
% в фигурных скобках в миллиметрах).

{\bf\color{red}Рецензенты:}%Здесь можно прописать любой текст (например, заменить слово
% <<Рецензенты>> на <<Эксперты>>

~~~~{\bf Фамилия Имя Отчество} -- должность

 ~~~~{\bf Фамилия Имя Отчество} -- должность
\end{flushleft}% Эта команда завершает выравнивание текста по левому краю.

\vspace{10mm}% Эта команда увеличивает расстояние между строками (расстояние указано
% в фигурных скобках в миллиметрах).

 Здесь можно расположить текст аннотации.

%-------------------------------------------------------------------------------------------------

\newpage% Эта команда задает переход на новую страницу (разрыв страницы).

% На этой странице мы зададим автоматическую генерацию раздела <<Содержание>> электронного
% учебника

\paneloverlay{but3.png}% Аргумент этой команды, записанный в фигурных скобках, можно
% изменить. <<{but3.png}>> -- это имя графического файла, который используется в качестве
% фона интерактивной панели. Здесь можно прописать имя любого рисунка в формате png или pdf,
% который Вы хотите использовать в качестве фона для интерактивной панели. Файл
% этого рисунка должен находиться в папке Images/Panel.

\overlay{overlay2.pdf}% Здесь мы снова меняем фон рабочей области.
% Аргумент этой команды, записанный в фигурных скобках, можно
% изменить. <<{overlay2.pdf}>> - это имя графического файла, который используется в качестве
% фона рабочей области. Здесь можно прописать имя любого рисунка в формате
% png или pdf, который Вы хотите использовать в качестве фона для основной Рабочей области.
% Файл этого рисунка должен находиться в папке Images/fon.

\renewcommand{\contentsname}{СОДЕРЖАНИЕ}% Здесь можно слово <<Содержание>> заменить на любое
% другое (например <<Оглавление>>)

\addtocontents{toc}% Эту команду не стоит менять.
\large\tableofcontents\large\label{oglo}% Эту команду не стоит менять.

\newpage% Эта команда задает переход на новую страницу (разрыв страницы).


%-----------------------------------------------------------------------------

\section*{Предисловие}% Эта команда начинает раздел <<Предисловие>>. Можно назвать этот раздел
% и по-другому.
\addcontentsline{toc}{struct}{Предисловие}% Эту команду не стоит менять. Она добавляет
% в раздел <<Содержание>> ссылку на раздел <<Предисловие>>.

 Дальше размещается текст этого раздела электронного учебника. Сам текст (при желании) можно
создать и в любом текстовом редакторе, а затем просто скопировать его и вставить сюда.
Но при этом нужно помнить важные <<мелочи>>, которые подробно описаны в
<<Руководстве пользователю>>, а о некоторых мы поговорим сейчас.

Абзацы отделяются друг от друга пустой строкой. Любое количество пустых строк
эквивалентны одной. Любое количество пробелов и символов табуляции, следующих
друг за другом, а также конец строки, считаются за один пробел.
Разбиение абзаца на строки, выравнивание текста и переносы
в словах делаются автоматически.

%-------------------------------------------------------------------------------------------

\newpage % Эта команда начинает новую страницу

\section*{ПРИМЕРНЫЙ ТЕМАТИЧЕСКИЙ ПЛАН} % Эта команда начинает новый раздел. Его название (текст
% в фигурных скобках) можно поменять.
\addcontentsline{toc}{struct}{Примерный тематический план}% Эта команда добавляет название
% раздела в раздел <<Содержание>>. Если меняете название раздела в предыдущей команде,
% то точно также меняйте текст в фигурных скобках этой команды.
{\normalsize% Эта команда уменьшает шрифт текста на данной странице до стандартного.
\begin{center}% Эта команда центрирует текст, заключенный между \begin{center} и \end{center}
\begin{longtable}{|c|p{12cm}|c|c|}% Эта команда начинает многостраничную таблицу (см. часть 4
% <<Руководства пользователю>>). Если Вас устраивает структура предлагаемой таблицы, не
%меняйте эту команду
\hline% Эта команда рисует горизонтальную линейку.
~ & ~ & ~ & ~  \\% Здесь вставлена пустая строка.
№ & \multicolumn{1}{|c|}{\bf Название  темы, перечень } & ЛК & ПР  \\% Здесь можно менять
~ & \multicolumn{1}{|c|}{\bf изучаемых вопросов}  & ~  &  ~ \\% любой текст на русском языке.
% ЛК -- сокращение для <<Лекции>>, ПР -- сокращение для <<Практические занятия>>.
   ~ & ~ & ~ & ~  \\% Здесь вставлена пустая строка.
\hline% Эта команда рисует горизонтальную линейку.
% Дальше следует продолжение таблицы с содержанием примерного тематического плана.
% Ячейки таблицы отделяются друг от друга знаком &, строки таблицы отделяются друг от друга
% командой \\.
% Первый столбец -- порядковый номер. Второй столбец -- название темы и перечень
% изучаемых вопросов. Третий столбец -- количество часов лекций, отводимое на изучение темы.
% Четвертый столбец -- количество часов практических (лабораторных)  занятий.
1 & {\bf Название темы.} Перечень изучаемых вопросов & 2  & 2  \\
\hline % Эта команда рисует горизонтальную линейку.
2& {\bf Название темы.} Перечень изучаемых вопросов  & 2  & 4  \\
\hline % Эта команда рисует горизонтальную линейку.
3& {\bf Название темы.} Перечень изучаемых вопросов  & 2  & 2  \\
\hline % Эта команда рисует горизонтальную линейку.
4& {\bf Название темы.} Перечень изучаемых вопросов  & 2  & 2  \\
\hline % Эта команда рисует горизонтальную линейку.
5& {\bf Название темы.} Перечень изучаемых вопросов  & 2  & 2  \\
\hline % Эта команда рисует горизонтальную линейку.
6& {\bf Название темы.} Перечень изучаемых вопросов  & 2  & 2  \\
\hline % Эта команда рисует горизонтальную линейку.
7& {\bf Название темы.} Перечень изучаемых вопросов  & 2  & 2  \\
\hline % Эта команда рисует горизонтальную линейку.
8& {\bf Название темы.} Перечень изучаемых вопросов  & 2  & 2  \\
\hline % Эта команда рисует горизонтальную линейку.
% Можете добавлять или удалять любое количество строк.

\end{longtable}% Эта команда завершает таблицу
\end{center}}% Эта команда завершает центрирование текста

%---------------------------------------------------------------------------------------------
\newpage
\chapter{Лямбда-выражения}
\section{Определение и назначение}
В Java лямбда-выражения представляют собой компактный способ объявления анонимных функций. Они позволяют передавать функции как параметры в другие методы, хранить функции в переменных и возвращать функции в качестве результата. Лямбда-выражения были введены в языке Java начиная с версии 8.

Синтаксис лямбда-выражений выглядит следующим образом:
\begin{lstlisting}
(parameters) -> expression
\end{lstlisting}
где parameters - список параметров функции, expression - выражение, которое выполняется при вызове функции. Если функция не принимает параметров, список parameters может быть пустым. Если функция выполняет более одной операции, выражение expression может быть заменено на блок кода, заключенный в фигурные скобки {}.

Пример использования лямбда-выражений для сортировки списка строк в порядке возрастания:
\begin{lstlisting}
List<String> names = Arrays.asList("John", "Alice", "Bob", "Doe");

// Sorting the list of lines in ascending order
Collections.sort(names, (a, b) -> a.compareTo(b));

// Output a sorted list
names.forEach(System.out::println);
\end{lstlisting}
Здесь мы передаем лямбда-выражение (a, b) -> {\bf a.compareTo(b)} в метод {\bf Collections.sort()}. Лямбда-выражение принимает две строки a и b и вызывает метод compareTo() для сравнения строк.Collections.sort() использует это сравнение для сортировки списка names.

Одной из ключевых особенностей лямбда-выражений является их способность захватывать переменные из окружающего контекста. Переменные, используемые в лямбда-выражении, должны быть либо объявлены как final, либо эффективно финализированы (то есть их значение не должно изменяться после инициализации). В противном случае компилятор выдаст ошибку.

Лямбда-выражения также могут быть использованы с функциональными интерфейсами. Функциональный интерфейс представляет собой интерфейс с единственным абстрактным методом. В Java 8 было введено множество предопределенных функциональных интерфейсов, таких как Predicate, Consumer, Supplier, Function и другие. Лямбда-выражения могут быть применены для создания экземпляров этих интерфейсов без явного объявления анонимных классов.

В целом, лямбда-выражения предоставляют более компактный и удобный способ работы с анонимными функциями в Java. Они позволяют писать более читаемый и выразительный код, особенно при использовании вместе с функциональными интерфейсами.
\section{Правила формирования лямбда-выражений}

Правила формирования лямбда-выражений в Java включают определение параметров, тела выражения и возможность захвата переменных из окружающего контекста. Вот подробное объяснение каждого аспекта правил:
\begin{enumerate} 
  \item Параметры:
  \begin{itemize} 
    \item Если лямбда-выражение не принимает никаких параметров, то пустые круглые скобки используются для объявления параметров: {\bf () -> expression}.
    \item Если лямбда-выражение принимает один параметр, то круглые скобки могут быть опущены: {\bf param -> expression}.
    \item Если лямбда принимает несколько параметров, они перечисляются через запятую в круглых скобках:
    {\bf (param1, param2) -> expression}.
    \end{itemize}

\item Тело выражения:
    \begin{itemize} 
    \item Если тело выражения состоит из единственного выражения, оно может быть указано без фигурных скобок. Это выражение будет использовано как возвращаемое значение: {\bf param -> expression}.
    \item Если тело выражения содержит несколько операций, оно должно быть заключено в фигурные скобки. В этом случае требуется явное указание оператора return, если требуется вернуть значение: {\bf param -> { statements; return value; }}.
    \end{itemize}
\item Захват переменных:
\begin{itemize} 
    \item Лямбда-выражение может захватывать переменные из окружающего контекста. Они могут быть либо объявлены как final, либо эффективно финализированы (то есть их значение не должно изменяться после инициализации).
    \item Если переменная объявлена в окружающем контексте и захвачена лямбда-выражением, она доступна внутри выражения по значению.
    \item Если переменная объявлена в окружающем контексте и изменяется внутри лямбда-выражения, это вызовет ошибку компиляции. В таком случае переменная должна быть объявлена как final или эффективно финализирована.
\end{itemize}
\end{enumerate}

Примеры лямбда-выражений с разными правилами формирования:
\begin{lstlisting}
// Lambda expression without parameters
() -> System.out.println("Hello, world!")
// Lambda expression with one parameter
x -> x * x
// Lambda expression with several parameters
(x, y) -> x + y
// Lambda expression with a body of one expression
(x, y) -> x > y ? x : y
// Lambda expression with a body of several operations
(x, y) -> {
    int sum = x + y;
    System.out.println("Sum: " + sum);
    return sum;
}
// Lambda expression with variable capturing from surrounding context
int factor = 2;
x -> x * factor
\end{lstlisting}
Лямбда-выражения должны соответствовать функциональному интерфейсу, то есть иметь совместимый тип параметров и возвращаемого значения. Функциональный интерфейс определяет сигнатуру лямбда-выражения и позволяет его использовать в контексте, требующем такого интерфейса
\section{Функциональные интерфейсы}
Функциональные интерфейсы являются основой для функционального программирования в Java. Они представляют интерфейсы, которые содержат только один абстрактный метод, называемый функциональным методом. Функциональные интерфейсы позволяют использовать лямбда-выражения и методы ссылок для создания анонимных функций.

Основная идея функциональных интерфейсов заключается в том, что они позволяют передавать поведение как аргументы методов или сохранять их в переменных. Это делает код более компактным и выразительным.

В Java 8 и выше функциональные интерфейсы могут быть использованы с лямбда-выражениями для создания анонимных функций. Лямбда-выражение представляет собой краткую и конкретную форму записи анонимных функций, которые могут быть переданы в качестве аргументов или присвоены переменным.

Java предоставляет аннотацию {\bf @FunctionalInterface}, которая может быть использована для явного обозначения интерфейса как функционального. Эта аннотация не является обязательной, но ее использование помогает явно указать намерение создать функциональный интерфейс.

Важно отметить, что функциональный интерфейс может иметь и другие методы помимо абстрактного метода, но только один абстрактный метод определяет его функциональность. Это позволяет функциональным интерфейсам содержать дополнительные методы по умолчанию или статические методы без нарушения их функциональности.

Java API предоставляет набор предопределенных функциональных интерфейсов в пакете {\bf java.util.function}, которые могут быть использованы для различных задач, таких как проверка условий, преобразование данных, потребление или поставка значений и т.д.
Концепция функциональных интерфейсов в Java основана на идее использования анонимных функций, которые могут быть переданы в качестве параметров или сохранены в переменных. Это позволяет программистам писать более компактный и выразительный код при работе с функциональными конструкциями.
\section{Основные функциональные интерфейсы в Java API}
Java API предоставляет набор предопределенных функциональных интерфейсов в пакете {\bf java.util.function}, которые упрощают работу с функциональным программированием и лямбда-выражениями. 
\begin{enumerate} 
\item Predicate<T> (предикат): Принимает один аргумент типа T и возвращает булево значение. Определяет функцию для проверки условия. Методы: test(T t) - проверяет условие на аргументе t.

Пример использования:
\begin{lstlisting}
Predicate<Integer> isPositive = num -> num > 0;
System.out.println(isPositive.test(5)); // true
\end{lstlisting}
\item Consumer<T> (потребитель): Принимает один аргумент типа T и не возвращает результат. Определяет функцию для выполнения действия над объектом типа T. Методы: accept(T t)-выполняет действие на аргументе t.

Пример использования:
\begin{lstlisting}
Consumer<String> printMessage = message -> System.out.println(message);
printMessage.accept("Hello, world!"); // Hello, world!
\end{lstlisting}
\item Function<T, R> (функция): Принимает аргумент типа T и возвращает результат типа R. Определяет функцию, которая преобразует объект типа T в объект типа R. Методы: apply(T t) - выполняет функцию на аргументе t.

Пример использования:
\begin{lstlisting}
Function<Integer, String> intToString = num -> String.valueOf(num);
System.out.println(intToString.apply(10)); // "10"
\end{lstlisting}

\item Supplier<T> (поставщик): Не принимает аргументов и возвращает объект типа T. Определяет функцию, которая поставляет (возвращает) объекты. Методы: get() - возвращает объект типа T.

Пример использования:
\begin{lstlisting}
Supplier<Integer> randomNumber = () -> new Random().nextInt();
System.out.println(randomNumber.get()); // случайное число
\end{lstlisting}
\item UnaryOperator<T> (унарный оператор): Принимает один аргумент типа T и возвращает результат типа T. Определяет функцию, которая преобразует объект типа T в объект того же типа. Методы: apply(T t) - выполняет операцию на аргументе t.

Пример использования:
\begin{lstlisting}
UnaryOperator<Integer> square = num -> num * num;
System.out.println(square.apply(5)); // 25
\end{lstlisting}
\end{enumerate}

Это лишь несколько примеров функциональных интерфейсов из пакета {\bf java.util.function}. Кроме того, в Java API есть множество других функциональных интерфейсов, таких как {\bf BiPredicate}, {\bf BiConsumer}, {\bf BiFunction}, {\bf Supplier} и т.д., которые работают с разным количеством аргументов или выполняют специфичные операции. Эти функциональные интерфейсы часто используются при работе с коллекциями, потоками данных (streams), параллельным программированием и другими функциональными конструкциями в Java.
\section{Выведение типов}

Выведение типов (type inference) в Java - это возможность компилятора Java автоматически определить тип переменной на основе контекста, в котором она используется, без явного указания типа программистом. Введение вывода типов в Java началось с появлением Java 5 и улучшилось в Java 7 с введением более широких возможностей вывода типов.

До появления вывода типов программист должен был явно указывать тип переменной при объявлении. 

Например:
\begin{lstlisting}
List<String> names = new ArrayList<String>();
\end{lstlisting}

С использованием вывода типов, компилятор может определить тип переменной на основе типа выражения, справа от знака равенства. Таким образом, вышеуказанное объявление переменной может быть записано следующим образом:

\begin{lstlisting}
List<String> names = new ArrayList<>();
\end{lstlisting}

В данном случае компилятор самостоятельно определит, что переменная names является списком строк {\bf (List<String>)} на основе типа выражения new ArrayList<>().

Помимо вывода типов для переменных, в Java также имеется вывод типов для обобщенных методов. Это означает, что компилятор может автоматически определить тип параметра метода на основе аргументов, переданных при вызове метода. 

Например:

\begin{lstlisting}
<T> void processList(List<T> list) {
    // list processing code
}

// Calling a method with an explicit type
List<String> names = new ArrayList<>();
processList<String>(names);

// Calling a method with type output
List<String> names = new ArrayList<>();
processList(names);

\end{lstlisting}

В последнем случае, компилятор самостоятельно определит, что тип T для метода {\bf processList} должен быть String на основе типа переменной names.

Однако следует отметить, что вывод типов имеет свои ограничения. Например, он не работает с непараметризованными обобщенными типами или с примитивными типами. Кроме того, вывод типов не является магическим и не заменяет необходимость понимания типов в вашем коде. Явное указание типов может быть полезно для ясности и улучшения читаемости кода.

Вывод типов в Java является мощным инструментом, который позволяет сократить объем кода и сделать его более гибким и читаемым. Однако, при использовании вывода типов, всегда следует убедиться, что типы выводятся корректно и соответствуют вашим ожиданиям, особенно при использовании сложных выражений и методов с обобщенными типами.

\newpage
\chapter{Потоки}

\section{Определение и назначение}

В Java потоки (threads) используются для параллельного выполнения кода. Они позволяют выполнять несколько задач одновременно, что особенно полезно при работе с многопоточными или асинхронными приложениями.

Назначение потоков в Java:

\begin{itemize} 
\item Параллельное выполнение: Основная цель потоков - обеспечить параллельное выполнение кода. При наличии нескольких потоков, различные части программы могут выполняться одновременно, улучшая производительность и сокращая общее время выполнения задачи.
\item Асинхронность: Использование потоков позволяет выполнять асинхронные операции. Например, вы можете запустить поток для выполнения длительной операции, не блокируя основной поток выполнения программы. Это особенно полезно для пользовательских интерфейсов, чтобы избежать зависания приложения во время выполнения длительных задач.
\item Обработка событий: Потоки позволяют реагировать на события, которые происходят параллельно. Например, вы можете создать поток, который ожидает событий от сетевого соединения или пользовательского ввода, и обрабатывает их независимо от других операций.
\item Многопоточность: В многопоточных приложениях несколько потоков могут одновременно работать с общими ресурсами. Правильное использование потоков позволяет избежать состояний гонки (race conditions) и синхронизировать доступ к общим данным. Это позволяет создавать более эффективные и отзывчивые приложения.
\item Параллельное программирование: Потоки также используются для реализации параллельных алгоритмов и вычислений. Вы можете разделить большую задачу на несколько меньших подзадач и запустить каждую подзадачу в отдельном потоке, чтобы ускорить общее время выполнения.
\end{itemize}
В Java потоки могут быть созданы с использованием класса Thread или путем реализации интерфейса {\bf Runnable} и передачи экземпляра класса {\bf Runnable} в конструктор Thread. Java также предоставляет более высокоуровневые абстракции для работы с потоками, такие как {\bf ExecutorService} и {\bf ThreadPoolExecutor}, которые облегчают управление потоками и пулами потоков.

Важно помнить о правильной синхронизации и координации между потоками при доступе к общим ресурсам и данным, чтобы избежать состояний гонки и других проблем, связанных с многопоточностью.
\section{Основные потоковые операции}

В Java существует несколько основных потоковых операций, которые позволяют выполнять различные операции с потоками данных. 

Некоторые из них:

\begin{enumerate} 
\item Чтение (Read): Операция чтения предназначена для чтения данных из потока. В Java для чтения данных из потоков существуют различные классы, такие как {\bf InputStream} и Reader, которые предоставляют методы для чтения данных различных типов, включая байты, символы и т.д. Примеры операций чтения включают read() для чтения отдельных байтов или символов и {\bf readLine()} для чтения строки из потока.
\item Запись (Write): Операция записи предназначена для записи данных в поток. Для записи данных в потоки в Java используются классы, такие как {\bf OutputStream} и Writer. Они предоставляют методы для записи данных различных типов, включая байты, символы и т.д. Примеры операций записи включают write() для записи отдельных байтов или символов и {\bf println()} для записи строки в поток.
\item Закрытие (Close): Операция закрытия потока предназначена для освобождения ресурсов, связанных с потоком, и завершения операций ввода-вывода. Для закрытия потока в Java используется метод close(). При закрытии потока также освобождаются любые связанные с ним системные ресурсы.
\item Cинхронизация (Synchronization): Синхронизация потоков позволяет управлять доступом к общим ресурсам или данным из нескольких потоков. В Java для этого используется механизм блокировок, включая ключевое слово synchronized и классы Lock и Condition. Синхронизация позволяет избежать состояний гонки и других проблем, связанных с одновременным доступом к общим ресурсам.
\item Буферизация (Buffering): Буферизация потоков позволяет улучшить производительность операций ввода-вывода путем чтения или записи данных пакетами во внутренний буфер перед фактической операцией ввода или вывода. В Java для буферизации потоков существуют классы, такие как {\bf BufferedInputStream} и {\bf BufferedWriter}, которые предоставляют более эффективные операции чтения и записи данных.
\item Маркировка (Mark/Reset): Операции маркировки и сброса позволяют установить маркер в потоке и затем вернуться к этой маркеру позже. В Java для этого используются методы mark() и reset(). Это полезно, когда требуется просмотреть некоторую часть данных в потоке и затем вернуться к предыдущей позиции в потоке.
\end{enumerate}

Это только некоторые из основных потоковых операций в Java. Существует множество других операций и классов, которые позволяют более гибко работать с потоками данных в различных сценариях.
\section{Объединение операций}

В Java объединение операций относится к механизму комбинирования нескольких операций в одну единицу работы. Объединение операций может быть полезным для выполнения нескольких операций атомарно или для оптимизации выполнения операций в определенном порядке. В языке Java существуют несколько способов реализации объединения операций.

\begin{itemize}
\item Транзакции (Transactions): Транзакции позволяют группировать несколько операций в одну логическую единицу работы. Транзакционное объединение операций обеспечивает атомарность, согласованность, изолированность и долговечность (ACID-свойства). В Java для реализации транзакций можно использовать различные технологии, такие как {\bf Java Transaction API (JTA)} или Java Database Connectivity (JDBC) в сочетании с поддержкой транзакций в базе данных.

\item Синхронизация (Synchronization): Синхронизация позволяет управлять доступом к общим ресурсам или данным из нескольких потоков. Это может быть использовано для объединения операций, чтобы они выполнялись в определенном порядке или атомарно. Ключевое слово synchronized в Java позволяет объявить блок кода или метод синхронизированным, гарантируя, что только один поток может выполнить этот блок кода или метод одновременно.
\item Атомарные операции (Atomic Operations): В Java есть классы, такие как {\bf AtomicInteger}, 
{\bf AtomicLong}, {\bf AtomicReference} и другие, которые предоставляют атомарные операции над своими значениями. Атомарные операции гарантируют, что операция будет выполнена целиком и никакой другой поток не может вмешаться в эту операцию. Это обеспечивает атомарность объединения операций.
\item Сборка мусора (Garbage Collection): Объединение операций также может быть связано со сборкой мусора. В Java сборка мусора автоматически освобождает память, занимаемую объектами, которые больше не используются. В процессе сборки мусора Java может объединять несколько независимых операций освобождения памяти в одну операцию, что улучшает производительность и эффективность.
\end{itemize}

Все эти механизмы позволяют объединять операции в Java с различными целями, такими как обеспечение атомарности, согласованности, оптимизации и управление доступом к общим ресурсам или данным. Выбор подходящего механизма зависит от конкретного сценария использования и требований вашего приложения.
\section{Идеоматическое сцепление потоковых вызовов}

Идеоматическое сцепление потоковых вызовов (idiomatic stream chaining) в Java относится к использованию потоковых операций для последовательной обработки данных в функциональном стиле. Это позволяет писать более читаемый и компактный код, упрощает манипуляции с данными и повышает читабельность программы. Основой идеоматического сцепления потоковых вызовов является работа с Java Stream API.

{\bf Java Stream API} предоставляет богатый набор операций для работы с коллекциями и другими источниками данных. Потоковые операции можно объединять в цепочки, где результат одной операции передается как входные данные для следующей операции. Это позволяет выполнять различные операции фильтрации, преобразования и агрегации данных без необходимости явного цикла.

Пример идеоматического сцепления потоковых вызовов в Java:

\begin{lstlisting}
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "Dave", "Eve");
List<String> result = names.stream()
    .filter(name -> name.length() > 3)
    .map(String::toUpperCase)
    .sorted()
    .collect(Collectors.toList());
\end{lstlisting}
В этом примере список строк names, и выполняем следующие операции:

\begin{enumerate}
\item Фильтрация: Оставить только те строки, длина которых больше 3
\item Преобразование: Привести строки к верхнему регистру
\item Сортировка: Отсортировать строки в алфавитном порядке
\item Сборка: Собрать результаты в новый список
\end{enumerate}

С использованием потоковых операций, мы можем записать эти операции в виде цепочки вызовов методов {\bf stream}(), {\bf filter()}, {\bf map()}, {\bf sorted()} и {\bf collect()}. Каждая операция применяется последовательно к элементам потока, и результат передается в следующую операцию.

Результат выполнения данного кода будет новый список result, содержащий отфильтрованные, преобразованные и отсортированные строки.

Идеоматическое сцепление потоковых вызовов позволяет создавать более выразительный код, упрощает чтение и понимание операций над данными. Кроме того, потоковые операции обеспечивают ленивую вычислительную модель, что может привести к повышению производительности при обработке больших объемов данных.


\end{document}% Эта команда завершает рабочий (исходный) файл электронного учебника

