% Электронный учебник будет представлять собой один файл в формате pdf.
% Для того, чтобы создать этот
% файл, нужно поработать с настоящим документом, который в дальнейшем будем называть
% <<рабочий файл>>. Прежде, чем приступать к работе, прочтите внимательно первые две части
% <<Руководства пользователю>>. По большому счету электронное издание <<Руководство
% пользователю>> показывает стиль и
% структуру создаваемого электронного учебника (стиль и структуру, конечно же, можно будет
% поменять по Вашему усмотрению). Основную часть экрана занимает так называемая рабочая
% область -- здесь будет представлена информация учебника, предназначенная для изучения
% студентами. Правая часть -- интерактивная панель, предназначенная для удобной навигации
% по документу.

% Теперь можно приступать к работе. Внимательно читайте все комментарии (они начинаются после
% символа %).
% Если Вы что-нибудь поменяли, то для того, чтобы увидеть результат,
% нужно скомпилировать рабочий файл в pdf-документ (см. <<Руководство пользователю>>).

%---------------------------------------------------------------------------------------------------------------

\documentclass[12pt, a4paper]{book}% Эту команду не стоит менять
\usepackage{xspace,colortbl}% Эту команду не стоит менять
\usepackage[utf8]{inputenc}% Эту команду не стоит менять
\usepackage[english,russian]{babel}% Эту команду не стоит менять
\usepackage{euscript,latexsym,amsfonts,amsthm,amsmath,amssymb}% Эту команду не стоит менять
\usepackage[pdftex,hypertex]{hyperref}% Эту команду не стоит менять
\usepackage{color}% Эту команду не стоит менять
\usepackage[screen,panelright,sectionbreak]{pdfscreen}% Эту команду не стоит менять
\graphicspath{{images/}{images/amblems/}{images/fon/}{images/panel/}{images/pic/}}% Эту
% команду не стоит менять. Она указывает путь к папкам, в которых хранятся графические файлы
 \margins{.25in}{.25in}{.25in}{.30in}% Эту команду не стоит менять
 \screensize{6.25in}{8in}% Эту команду не стоит менять
  \changeoverlay% Эту команду не стоит менять
\usepackage{longtable}% Эту команду не стоит менять

\usepackage{regexpatch}
\usepackage{listings}
\definecolor{keyword}{RGB}{0,0,150}
\definecolor{identifier}{RGB}{0,0,0}
\definecolor{comment}{RGB}{128,128,128}
\definecolor{string}{RGB}{0,128,0}
\definecolor{numbers}{RGB}{128,128,128}
\lstdefinestyle{customjava}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=java,
  numbers=left,
  showstringspaces=false,
  basicstyle=\small\ttfamily,
  numberstyle=\color{numbers},
  keywordstyle=\bfseries\color{keyword},
  commentstyle=\itshape\color{comment},
  identifierstyle=\color{identifier},
  stringstyle=\color{string},
}
\lstset{escapechar=@,style=customjava}
\makeatletter
\xpatchcmd*\@Overlay@Hook{\put(\strip@pt\@tempdima,\strip@pt\@tempdima)}
{\put(\strip@pt\@tempdima,\strip@pt\dimexpr.5\paperheight)}{}{}
\makeatother

%--------------------------------------------------------------------------------------------

 \paneloverlay{but3.png}% Аргумент этой команды, записанный в фигурных скобках, можно
% изменить. <<{but3.png}>> -- это имя графического файла, который используется в качестве
% фона интерактивной панели. Здесь можно прописать имя любого рисунка в формате png или pdf,
% который Вы хотите использовать в качестве фона для интерактивной панели. Файл
% этого рисунка должен находиться в папке Images/Panel.

%---------------------------------------------------------------------------------------------------

\overlay{m1.png} % Аргумент этой команды, записанный в фигурных скобках, можно
% изменить. <<{m8.png}>> -- это имя графического файла, который используется в качестве
% фона основой рабочей области. Здесь можно прописать имя любого рисунка в формате
% png или pdf, который Вы хотите использовать в качестве фона для основной рабочей области.
% Файл этого рисунка должен находиться в папке Images/fon.

%---------------------------------------------------------------------------------------------

\def\panel{\begin{minipage}[t][\paperheight][t]{\panelwidth}% Эту команду не стоит менять
\centering\null\vspace*{12pt}% Эту команду не стоит менять
 \par\vspace{0.3cm}% Эту команду не стоит менять

%---------------------------------------------------------------------------------------------

\includegraphics[width=2.54cm]{favicon_ru_RU.png}\par\vspace{0.6cm}% Эта команда позволяет вставить
% любую картинку в качестве эмблемы в верхней части интерактивной панели. Аргумент команды
% в квадратных скобках <<[width=2.54cm]>> задает ширину эмблемы (в сантиметрах),
% а аргумент команды в фигурных скобках <<{univ.png}>> -- это имя графического файла,
% содержащего саму эмблему. Здесь можно прописать имя любого рисунка в формате
% png или pdf, который Вы хотите использовать в качестве эмблемы.
% Файл этого рисунка должен находиться в папке Images/amblems
\vspace{0mm}% Эта команда задает расстояние (в миллиметрах) до следующей после эмблемы строки
{\LARGE\itshape Кафедра}% Эту команду лучше не менять

{\large\itshape ИИ}% Впишите сюда название Вашей кафедры

\vspace{5mm}% Эта команда задает расстояние (в миллиметрах) до первой кнопки
% интерактивной панели
%---------------------------------------------------------------------------------------------------

 \Acrobatmenu{FirstPage}{\addButton{1.05in}{\FBlack\@Начало}}\par\vspace{3mm} % Эта команда создает
% кнопку <<Начало>> на интерактивной панели. Нажатие этой кнопки возвращает пользователя
% на первую (титульную) страницу электронного учебника. Аргумент команды <<{\FBlack\@Начало}>>
% можно поменять (например, написать вместо <<Начало>> <<Пачатак>> или <<Титульная страница>>).

%------------------------------------------------------------------------------------------------

\hyperref[oglo]{{\addButton{1.05in}{\@Содержание}}}\par\vspace{3mm} %Эта команда создает
% кнопку <<Содержание>> на интерактивной панели. Нажатие этой кнопки возвращает пользователя
% на первую страницу раздела <<Содержание>> электронного учебника.
% Аргумент команды <<{\@Содержание}>> можно поменять (например, написать
% вместо <<Содержание>> <<Змест>> или <<Оглавление>>).

%---------------------------------------------------------------------------------------------

\hyperref[mybutton]{\addButton{1.05in}{\@Ваша кнопка}}\par\vspace{3mm}%Эта команда создает
% кнопку <<Ваша кнопка>> на интерактивной панели. Нажатие этой кнопки вернет пользователя
% на ту страницу электронного учебника, на которую Вы захотите. Для этого нужно в определенное
% Вами место любого раздела электронного учебника поставить метку \label{mybutton} (подробнее
% о метках можно прочитать в <<Руководстве пользователю>>). Обратите внимание, что имя этой
% метки должно совпасть с аргументом команды, записанном
% в квадратных скобках (\hyperref[mybutton]).
% Аргумент команды <<{\@Ваша кнопка}>> нужно поменять (написать
% вместо <<Ваша кнопка>> любой текст, указывающий пользователю, какую информацию он
% получит, нажав на эту кнопку). Такого типа кнопки удобно создавать для быстрого
% доступа пользователя к некоторой информации электронного учебника (например, справочной
% информации, перечню формул, и т.д.). При желании таких кнопок можно создать несколько
% (сколько позволит высота Интерактивной панели). Для этого нужно соответствующее
% число раз скопировать и вставить сразу после этого комментария
% команду \hyperref[imyametki]{\addButton{1.05in}{\@Ваша кнопка}}\par\vfill
% Если же Вы не хотите создавать ни одной своей кнопки, удалите всю строку, содержащую
% описываемую здесь команду и весь текст данного комментария.

%--------------------------------------------------------------------------------------------

\Acrobatmenu{PrevPage}{\addButton{.51in}% Не меняйте эту команду. Она создает кнопку перехода
{\FBlack\scalebox{.8}[1.4]{\btl}}}\hspace{1pt}% на одну страницу назад
\Acrobatmenu{NextPage}{\addButton{.51in}% Не меняйте эту команду. Она создает кнопку перехода
{\LBlack\scalebox{.8}[1.4]{\rtl}}}\par\vspace{3mm}% на одну страницу вперед

%---------------------------------------------------------------------------------------------

\Acrobatmenu{FirstPage}{\addButton{.51in}% Не меняйте эту команду. Она создает кнопку быстрого
{\FBlack\scalebox{.8}[1.4]{\btl\btl}}}\hspace{1pt}% перехода на первую страницу
\Acrobatmenu{LastPage}{\addButton{.51in}% Не меняйте эту команду. Она создает кнопку быстрого
{\LBlack\scalebox{.8}[1.4]{\rtl\rtl}}}\par\vspace{3mm}% перехода на последнюю страницу

%---------------------------------------------------------------------------------------------

\Acrobatmenu{GoToPage}{\addButton{1.05in}% Не меняйте эту команду. Она создает кнопку,
{\@Страница~\thepage~\@из~\pageref*{pages_total}}}\par\vspace{3mm}% позволяющую совершать
% переход на любую страницу электронного учебника

%---------------------------------------------------------------------------------------------

\Acrobatmenu{GoBack}{\addButton{1.05in} {\@Назад}}\par\vspace{3mm}% Не меняйте эту команду. Она
% создает удобную кнопку возврата к той странице электронного учебника, с которой был совершен
% переход по любой гиперссылке текста учебника или по некоторой кнопке Интерактивной панели.
% Аргумент команды <<{\@Назад}>> можно поменять (например написать вместо <<Назад>>
% <<Обратно>> или <<Возврат>>).

%---------------------------------------------------------------------------------------------------

\Acrobatmenu{FullScreen}{\addButton{1.05in}{\@На весь экран}}\par\vspace{3mm}% Эту команду лучше
% не менять. Она создает кнопку, позволяющую <<развернуть>> электронный учебник на весь экран.
% Аргумент команды <<{\@На весь экран}>> можно поменять (например написать вместо
% <<На весь экран>> <<Развернуть>> или <<Увеличить>>)

%---------------------------------------------------------------------------------------------

\Acrobatmenu{Quit}{\addButton{1.05in}{\@Закрыть}}\par\vspace{3mm}% Эту команду лучше
% не менять. Она создает кнопку, нажатие которой закрывает электронный учебник. Аргумент
% команды <<{\@Закрыть}>> можно поменять (например написать вместо
% <<Закрыть>> <<Выход>> или <<Уйти>>)

%---------------------------------------------------------------------------------------------

\end{minipage}}% Эту команду не стоит менять

\definecolor{panelbackground}{gray}{.8}% Эту команду не стоит менять
  \definecolor{buttonbackground}{gray}{.9}% Эту команду не стоит менять
  \definecolor{buttonshadow}{gray}{.2}% Эту команду не стоит менять
  \definecolor{orange}{rgb}{1,.549,0}% Эту команду не стоит менять
  \definecolor{orange1}{rgb}{1,.5,0}% Эту команду не стоит менять
  \definecolor{section0}{rgb}{0,.5,.1}% Эту команду не стоит менять
  \definecolor{section1}{rgb}{0,.5,1}% Эту команду не стоит менять
  \definecolor{section2}{rgb}{0,.5,.5}% Эту команду не стоит менять
  \definecolor{section3}{rgb}{0,.5,.4}% Эту команду не стоит менять
  \definecolor{section4}{rgb}{.4,.5,.2}% Эту команду не стоит менять
  \definecolor{section5}{rgb}{.5,.5,.3}% Эту команду не стоит менять
\newcommand{\esup}{\mathop{\rm ess\:sup\;}_{t>0\;\,}}% Эту команду не стоит менять
\newcommand{\res}{\mathop{\rm res}}% Эту команду не стоит менять
\renewcommand{\Re}{{\rm Re}}% Эту команду не стоит менять
\renewcommand{\Im}{\operatorname{Im}}% Эту команду не стоит менять
\newcommand{\norm}[1]{\left\Vert#1\right\Vert}% Эту команду не стоит менять
\newcommand{\set}[1]{\left\{#1\right\}}% Эту команду не стоит менять
\newcommand{\h}{{\mathcal H}}% Эту команду не стоит менять
\newcommand{\nur}{\EuScript{L}_{\nu,r}}% Эту команду не стоит менять
\newcommand{\nutwo}{\EuScript{L}_{\nu,2}}% Эту команду не стоит менять
\newcommand{\eqdef}{\stackrel{\rm def}{=}}% Эту команду не стоит менять
\renewcommand{\thesection}{\arabic{chapter}.\arabic{section}\hspace{-4mm}}% Эти команды не стоит менять
\renewcommand{\thesubsection}{\arabic{chapter}.\arabic{section}.% Эту команду не стоит менять
\arabic{subsection}\hspace{-4mm}}% Эту команду не стоит менять
\renewcommand{\theequation}{\arabic{chapter}.\arabic{equation}}% Эту команду не стоит менять
\makeatletter% Эту команду не стоит менять
\newcommand*\l@struct{\@dottedtocline{1}{0em}{2.3em}}% Эту команду не стоит менять
\newcommand{\l@abcd}[2]{\rightskip=\@pnumwidth\leftskip=% Эту команду не стоит менять
\@tempdima\hspace{-2.7em}\noindent #1\hfill% Эту команду не стоит менять
\rlap{\makebox[\@pnumwidth][r]{\bf#2}}}% Эту команду не стоит менять
\renewcommand*\l@section{\@dottedtocline{1}{1.5em}{2.2em}}% Эту команду не стоит менять
\renewcommand*\l@subsection{\@dottedtocline{2}{3.8em}{3.0em}}% Эту команду не стоит менять
\renewcommand{\section}{\@startsection{section}{1}{1pt}% Эту команду не стоит менять
{4.0ex plus -0.2ex minus -0.2ex}{2.0ex plus 0.2ex}{\centering\bf}}% Эту команду не стоит менять
\renewcommand{\subsection}{\@startsection{subsection}{2}% Эту команду не стоит менять
{23pt}{3.5ex plus -0.2ex minus -0.2ex}{1ex plus 0.2ex}{\bf}}% Эту команду не стоит менять
\renewcommand{\chapter}{\vspace{8mm}\global\@topnum=0% Эту команду не стоит менять
\@afterindenttrue\secdef\@chapter\@schapter}% Эту команду не стоит менять
\renewcommand{\@makechapterhead}[1]{{\parindent=0pt\raggedright% Эту команду не стоит менять
\bf ЛЕКЦИЯ { }\centering\Large\thechapter\vspace{0.1mm}~\centering% здесь можно заменить
% слово <<ЛЕКЦИЯ>> на любое другое

\large\bf #1\par\nopagebreak\vspace{4mm}}}% Эту команду не стоит менять

\renewcommand{\tableofcontents}{\section*{\contentsname}\@starttoc{toc}}% Эту команду не
% стоит менять

%--------------------------------------------------------------------------------------------

% Следующие команды задают вид и структуру раздела <<Содержание>> (этот раздел
% генерируется автоматически).
\def\@chapter[#1]#2{\ifnum \c@secnumdepth >\m@ne% Эту команду не стоит менять
\if@mainmatter% Эту команду не стоит менять
\refstepcounter{chapter}% Эту команду не стоит менять
\typeout{\@chapapp\space\thechapter.}% Эту команду не стоит менять
\addcontentsline{toc}{chapter}% Эту команду не стоит менять
{{\rm Лекция \,\thechapter}\ \ #1}% Здесь можно заменить слово <<Лекция>> на любое другое
\else% Эту команду не стоит менять
\addcontentsline{toc}{chapter}{#1}% Эту команду не стоит менять
\fi% Эту команду не стоит менять
\else% Эту команду не стоит менять
\addcontentsline{toc}{chapter}{#1}% Эту команду не стоит менять
\fi% Эту команду не стоит менять
\chaptermark{#1}% Эту команду не стоит менять
\addtocontents{lof}{\protect\addvspace{10\p@}}% Эту команду не стоит менять
\addtocontents{lot}{\protect\addvspace{10\p@}}% Эту команду не стоит менять
\if@twocolumn% Эту команду не стоит менять
\@topnewpage[\@makechapterhead{#2}]% Эту команду не стоит менять
\else% Эту команду не стоит менять
\@makechapterhead{#2}% Эту команду не стоит менять
\@afterheading% Эту команду не стоит менять
\fi}% Эту команду не стоит менять

\makeatother% Эту команду не стоит менять

%--------------------------------------------------------------------------------------------

% Следующие команды определяют имена окружений типа <<Теорема>> (см. <<Руководство
% пользователю>>).
% Аргумент команды \newtheorem, записанный в фигурных скобках -- это имя окружения,
% которое будет использоваться при записи команды, создающей соответствующее окружение
% в тексте электронного учебника, а поэтому оно должно состоять из латинских символов;
% команда \color{red} задает цвет надписи имени окружения на русском языке
% (доступные цвета: red (красный), gray (серый), orange (оранжевый), blue (голубой),
% green (зеленый) и т.д).
% Можно создавать свои собственные окружения такого типа. Например, команда
% \newtheorem{mymicl}{\indent \color{red}Моя мысль}[chapter] создаст окружение
% типа <<Теорема>> с именем <<Моя мысль>>.
\newtheorem{theorem}{\indent \color{red}Теорема}[chapter]
\newtheorem{lemma}{\indent \color{red}Лемма}[chapter]
\newtheorem{corollary}{\indent \color{red}Следствие}[chapter]
\newtheorem{note}{\indent \color{red}Замечание}[chapter]
\newtheorem{opr}{\indent \color{red}Определение}[chapter]
\newtheorem{example}{\indent \color{red}Пример}[chapter]
\newtheorem{utv}{\indent \color{red}Утверждение}[chapter]
\newtheorem{gip}{\indent \color{red}Гипотеза}[chapter]

%--------------------------------------------------------------------------------------------

\pagestyle{empty}% Эту команду не стоит менять



% Теперь вся подготовительная работа проведена, стиль и структура электронного
% учебника заданы. Дальше можно начинать наполнение электронного учебника.

% -----------------------------------------------------------------------------------------

\begin{document}\large% Эту команду не стоит менять
% Приступим к созданию титульной страницы. Далее можно менять все, что написано
% на русском языке. Но не забывайте читать комментарии.
\begin{center}% Эту команду не стоит менять. Она <<центрирует>> текст, заключенный между
% командами \begin{center} и \end{center}, по ширине экрана.
  УЧРЕЖДЕНИЕ ОБРАЗОВАНИЯ\\
  <<Брестский государственный технический университет>>
\end{center}% Эта команда завершает <<центрирование>> текста
\vspace{20mm}% Эта команда увеличивает расстояние между строками (расстояние указано
% в фигурных скобках в миллиметрах).
\begin{center}% Эту команду не стоит менять. Она <<центрирует>> текст, заключенный между
% командами \begin{center} и \end{center}, по ширине экрана.
\textbf{% Эта команда задает полужирный шрифт текста, являющегося аргументом
% команды (т.е. текста, заключенного в фигурные скобки)
     {\LARGE \color{red} СИСТЕМНОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ}\\[10mm]% Переход на следующую строку
% задан командой \\, а в квадратных скобках указано расстояние
% до следующей строки текста (в миллиметрах).
    \\[10mm]% Переход на следующую строку задан командой \\,
% а в квадратных скобках указано расстояние до следующей строки текста (в миллиметрах).
    {\it\Large Электронный учебно-методический комплекс }\\% Переход на следующую строку
% задан командой \\
    {\it\Large для студентов факультета электронно-информационных систем}% Любую из строк такого вида можно
% при желании удалить или добавить новую с произвольным текстом.
}
\end{center}% Эта команда завершает <<центрирование>> текста
\vspace{30mm}% Эта команда увеличивает расстояние между строками (расстояние указано
% в фигурных скобках в миллиметрах).
\begin{center}% Эту команду не стоит менять. Она центрирует текст, заключенный между
% командами \begin{center} и \end{center}, по ширине экрана.
Брест\\% Переход на следующую строку задан командой \\
БрГТУ\\% Переход на следующую строку задан командой \\
  2023% Здесь указывается год создания электронного учебника
\end{center}% Эта команда завершает <<центрирование>> текста

% --------------------------------------------------------------------------------------------

\newpage% Эта команда задает переход на новую страницу (разрыв страницы).

% На этой странице будет размещена информация об авторах, рецензентах, экспертах и т.д.
% Прежде, чем приступать к работе с этой страницей,
% прочитайте часть 3 <<Руководства пользователю>>.

 \overlay{m1.png}% Эта команда задает новый фон рабочей области. Аргумент этой команды,
% записанный в фигурных скобках, можно  изменить. <<{m1.png}>> -- это имя графического
% файла, который используется в качестве фона основой рабочей области. Здесь можно
% прописать имя любого рисунка в формате png или pdf, который Вы хотите использовать
% в качестве фона для основной рабочей области.
% Файл этого рисунка должен находиться в папке Images/fon.

{\large% Эта команда задает шрифт определенного размера (см. <<Руководство пользователю>>)
\begin{flushleft}% Эту команду не стоит менять. Она выравнивает по левому краю текст,
% заключенный между командами \begin{flushleft} и \end{flushleft}.
 {\bf\color{red} Авторы:}% Здесь можно прописать любой текст (например, заменить слово
% <<Авторы>> на <<Авторы-составители>>

% Ниже команды \bf задают полужирный шрифт текста в группе, заключенной в фигурные скобки

~~~~{\bf Фамилия Имя Отчество} -- должность


~~~~{\bf Фамилия Имя Отчество} -- должность

~~~~{\bf Фамилия Имя Отчество} -- должность

~~~~{\bf Фамилия Имя Отчество} -- должность


\vspace{10mm}% Эта команда увеличивает расстояние между строками (расстояние указано
% в фигурных скобках в миллиметрах).

{\bf\color{red}Рецензенты:}%Здесь можно прописать любой текст (например, заменить слово
% <<Рецензенты>> на <<Эксперты>>

~~~~{\bf Фамилия Имя Отчество} -- должность

 ~~~~{\bf Фамилия Имя Отчество} -- должность
\end{flushleft}% Эта команда завершает выравнивание текста по левому краю.

\vspace{10mm}% Эта команда увеличивает расстояние между строками (расстояние указано
% в фигурных скобках в миллиметрах).

 Здесь можно расположить текст аннотации.

%-------------------------------------------------------------------------------------------------

\newpage% Эта команда задает переход на новую страницу (разрыв страницы).

% На этой странице мы зададим автоматическую генерацию раздела <<Содержание>> электронного
% учебника

\paneloverlay{but3.png}% Аргумент этой команды, записанный в фигурных скобках, можно
% изменить. <<{but3.png}>> -- это имя графического файла, который используется в качестве
% фона интерактивной панели. Здесь можно прописать имя любого рисунка в формате png или pdf,
% который Вы хотите использовать в качестве фона для интерактивной панели. Файл
% этого рисунка должен находиться в папке Images/Panel.

\overlay{overlay2.pdf}% Здесь мы снова меняем фон рабочей области.
% Аргумент этой команды, записанный в фигурных скобках, можно
% изменить. <<{overlay2.pdf}>> - это имя графического файла, который используется в качестве
% фона рабочей области. Здесь можно прописать имя любого рисунка в формате
% png или pdf, который Вы хотите использовать в качестве фона для основной Рабочей области.
% Файл этого рисунка должен находиться в папке Images/fon.

\renewcommand{\contentsname}{СОДЕРЖАНИЕ}% Здесь можно слово <<Содержание>> заменить на любое
% другое (например <<Оглавление>>)

\addtocontents{toc}% Эту команду не стоит менять.
\large\tableofcontents\large\label{oglo}% Эту команду не стоит менять.

\newpage% Эта команда задает переход на новую страницу (разрыв страницы).


%-----------------------------------------------------------------------------

\section*{Предисловие}% Эта команда начинает раздел <<Предисловие>>. Можно назвать этот раздел
% и по-другому.
\addcontentsline{toc}{struct}{Предисловие}% Эту команду не стоит менять. Она добавляет
% в раздел <<Содержание>> ссылку на раздел <<Предисловие>>.

 Дальше размещается текст этого раздела электронного учебника. Сам текст (при желании) можно
создать и в любом текстовом редакторе, а затем просто скопировать его и вставить сюда.
Но при этом нужно помнить важные <<мелочи>>, которые подробно описаны в
<<Руководстве пользователю>>, а о некоторых мы поговорим сейчас.

Абзацы отделяются друг от друга пустой строкой. Любое количество пустых строк
эквивалентны одной. Любое количество пробелов и символов табуляции, следующих
друг за другом, а также конец строки, считаются за один пробел.
Разбиение абзаца на строки, выравнивание текста и переносы
в словах делаются автоматически.

%-------------------------------------------------------------------------------------------

\newpage % Эта команда начинает новую страницу

\section*{ПРИМЕРНЫЙ ТЕМАТИЧЕСКИЙ ПЛАН} % Эта команда начинает новый раздел. Его название (текст
% в фигурных скобках) можно поменять.
\addcontentsline{toc}{struct}{Примерный тематический план}% Эта команда добавляет название
% раздела в раздел <<Содержание>>. Если меняете название раздела в предыдущей команде,
% то точно также меняйте текст в фигурных скобках этой команды.
{\normalsize% Эта команда уменьшает шрифт текста на данной странице до стандартного.
\begin{center}% Эта команда центрирует текст, заключенный между \begin{center} и \end{center}
\begin{longtable}{|c|p{12cm}|c|c|}% Эта команда начинает многостраничную таблицу (см. часть 4
% <<Руководства пользователю>>). Если Вас устраивает структура предлагаемой таблицы, не
%меняйте эту команду
\hline% Эта команда рисует горизонтальную линейку.
~ & ~ & ~ & ~  \\% Здесь вставлена пустая строка.
№ & \multicolumn{1}{|c|}{\bf Название  темы, перечень } & ЛК & ПР  \\% Здесь можно менять
~ & \multicolumn{1}{|c|}{\bf изучаемых вопросов}  & ~  &  ~ \\% любой текст на русском языке.
% ЛК -- сокращение для <<Лекции>>, ПР -- сокращение для <<Практические занятия>>.
   ~ & ~ & ~ & ~  \\% Здесь вставлена пустая строка.
\hline% Эта команда рисует горизонтальную линейку.
% Дальше следует продолжение таблицы с содержанием примерного тематического плана.
% Ячейки таблицы отделяются друг от друга знаком &, строки таблицы отделяются друг от друга
% командой \\.
% Первый столбец -- порядковый номер. Второй столбец -- название темы и перечень
% изучаемых вопросов. Третий столбец -- количество часов лекций, отводимое на изучение темы.
% Четвертый столбец -- количество часов практических (лабораторных)  занятий.
1 & {\bf Название темы.} Перечень изучаемых вопросов & 2  & 2  \\
\hline % Эта команда рисует горизонтальную линейку.
2& {\bf Название темы.} Перечень изучаемых вопросов  & 2  & 4  \\
\hline % Эта команда рисует горизонтальную линейку.
3& {\bf Название темы.} Перечень изучаемых вопросов  & 2  & 2  \\
\hline % Эта команда рисует горизонтальную линейку.
4& {\bf Название темы.} Перечень изучаемых вопросов  & 2  & 2  \\
\hline % Эта команда рисует горизонтальную линейку.
5& {\bf Название темы.} Перечень изучаемых вопросов  & 2  & 2  \\
\hline % Эта команда рисует горизонтальную линейку.
6& {\bf Название темы.} Перечень изучаемых вопросов  & 2  & 2  \\
\hline % Эта команда рисует горизонтальную линейку.
7& {\bf Название темы.} Перечень изучаемых вопросов  & 2  & 2  \\
\hline % Эта команда рисует горизонтальную линейку.
8& {\bf Название темы.} Перечень изучаемых вопросов  & 2  & 2  \\
\hline % Эта команда рисует горизонтальную линейку.
% Можете добавлять или удалять любое количество строк.

\end{longtable}% Эта команда завершает таблицу
\end{center}}% Эта команда завершает центрирование текста

%---------------------------------------------------------------------------------------------

\newpage % Эта команда начинает новую страницу
\chapter{Ссылочный тип данных. Операции над переменными ссылочного типа}% Эта команда начинает первую лекцию. В фигурных скобках нужно
% записать тему лекции. Эта тема лекции автоматически получит порядковый номер и
% автоматически добавится в раздел <<Содержание>>. Лекций можно создавать сколько угодно.
% Для создания новой лекции скопируйте и вставьте (или наберите с клавиатуры) команду
% \chapter{Тема лекции} в любую часть рабочего файла. Можете смело менять местами лекции --
% вся нумерация после очередной компиляции поменяется автоматически.

% При необходимости здесь можно разместить любой текст

\section{Понятие ссылочного типа и null-ссылки}

В Java есть два типа данных: примитивные и ссылочные. Примитивные типы данных, такие как int, double, boolean, хранят значения непосредственно в переменной. Ссылочные типы данных, такие как String, Object, ArrayList, хранят ссылку на объект, который находится в динамической памяти (heap).

Ссылка на объект представляет собой адрес в памяти, где хранятся данные объекта. Это позволяет разделять данные между разными переменными, которые ссылаются на один и тот же объект.

Когда вы создаете объект ссылочного типа, вы выделяете память в динамической памяти для хранения данных объекта, и возвращается ссылка на этот объект. Вы можете использовать эту ссылку для доступа к данным объекта и выполнения операций над ним.

Однако, если ссылка на объект не указывает на какой-либо объект, то ее значение равно null. null является специальным значением, которое означает отсутствие объекта. Таким образом, null-ссылка является ссылкой, которая не указывает на объект, и любая попытка доступа к ней приведет к ошибке времени выполнения (NullPointerException).

Чтобы избежать ошибок с null-ссылками, в Java есть несколько методов, которые помогают проверять наличие объекта перед его использованием, например, методы isNull() и nonNull() из класса Objects.

Важно понимать, что ссылочные типы данных в Java передаются по значению. Это означает, что когда вы передаете ссылку на объект в метод, вы передаете копию этой ссылки, а не сам объект. Как следствие, любые изменения, которые вы делаете с объектом внутри метода, будут отражены на самом объекте, на который ссылается ссылка.

\section{Создание объекта ссылочного типа}

Объекты в Java создаются оператором new и хранятся в динамической памяти (heap). Когда вы создаете объект, JVM выделяет память для этого объекта и возвращает ссылку на его адрес.

Например, следующий код создает объект типа String и ссылку на него:

\begin{lstlisting}
    public class Test
    {
        public static void main(String[] args)
        {
            String myString = new String("Hello world!");
        }
    }
\end{lstlisting}

В этом примере myString является ссылочной переменной типа String, которая ссылается на объект String в памяти. Это означает, что myString не хранит саму строку "Hello world!",а только ссылку на нее.

Null-ссылка в Java представляет собой ссылку, которая не указывает на объект в памяти. Она может использоваться, например, для обозначения отсутствия значения или ошибки. 

Вы можете присвоить ссылке значение null явно, например:

\begin{lstlisting}
    public class Test
    {
        public static void main(String[] args)
        {
            String myNullString = null;
        }
    }
\end{lstlisting}

В этом примере myNullString является null-ссылкой, то есть она не указывает на объект в памяти.

Попытка обращения к null-ссылке приводит к возникновению исключения {\bf NullPointerException}.

Например:

\begin{lstlisting}
    public class Test
    {
        public static void main(String[] args)
        {
            String myString = null;
            System.out.println(myString.length());
        }
    }
\end{lstlisting}

В этом примере переменной {\bf myString} является null-ссылкой, поэтому при попытке вызвать метод length() на ней возникает исключение {\bf NullPointerException}.

Чтобы избежать ошибки, можно проверить, является ли ссылка null, прежде чем вызывать методы на ней. 

Например:

\begin{lstlisting}
    public class Test
    {
        public static void main(String[] args)
        {
            String myString = null;
            if (myString != null) {
                System.out.println(myString.length());
            }
        }
    }
\end{lstlisting}

В этом примере if-условие проверяет, является ли ссылка {\bf myString} null, и только если это не так, вызывает метод length(). Если ссылка является null, то блок не выполнится, и ошибки {\bf NullPointerException} не будет.

\section{Достижимость объекта}

Достижимость объекта в Java - это концепция, которая определяет, может ли объект быть доступен для использования программой в данный момент времени. Если объект достижим, то это означает, что у программы есть ссылка на этот объект, и она может использовать эту ссылку для доступа к данным объекта. Если объект недостижим, то это означает, что у программы нет ссылки на этот объект, и он не может быть использован.

В Java, объект считается достижимым, если он доступен через какую-то ссылку из стека вызовов (call stack) или из глобальной переменной (static field). Если нет никакой ссылки на объект, то он считается недостижимым и может быть удален сборщиком мусора (garbage collector).

Существует несколько способов, которыми объект может быть сделан недостижимым и, следовательно, быть удален сборщиком мусора:

1. Объект становится недостижимым, когда ссылка на него удаляется из стека вызовов или из глобальной переменной.

2. Объект становится недостижимым, когда ссылка на него перенаправляется на другой объект.

3. Объект становится недостижимым, когда ссылка на него становится недостижимой.

Следует отметить, что сборщик мусора не может гарантировать точный момент удаления недостижимого объекта. Вместо этого он удаляет объекты во время своего собственного цикла работы, который может быть запущен автоматически или по запросу программы.

В целом, в Java программисты не заботятся о непосредственном освобождении памяти, потому что это обеспечивает сборщик мусора. Однако, в некоторых случаях, когда работа с большими объемами данных, может быть полезно освободить память вручную, чтобы избежать переполнения памяти.

Пример:
\begin{lstlisting}
    public class Test
    {
        public static void main(String[] args)
        {
            String myString = null;
            if (myString != null) {
                System.out.println(myString.length());
            }
        }
    }
\end{lstlisting}
В этом примере мы создаем три объекта класса {\bf MyClass} и присваиваем каждому объекту ссылку. Затем мы переназначаем ссылку obj2 на объект {\bf obj3} и делаем ссылку {\bf obj1} равной null. Теперь первый объект {\bf MyClass}, созданный с помощью {\bf obj1}, недостижим, потому что на него больше нет ссылок. Этот объект может быть удален сборщиком мусора.

\section{Передача по значению и ссылке}
В Java переменные могут быть переданы в методы как по значению, так и по ссылке. 

Когда переменная передается по значению, метод получает копию значения этой переменной, и изменения этой копии не влияют на оригинальную переменную в вызывающем коде. 

Когда переменная передается по ссылке, метод получает ссылку на оригинальную переменную, и изменения, внесенные в переменную внутри метода, влияют на оригинальную переменную в вызывающем коде.

При передаче примитивных типов данных, таких как int, double, boolean, переменные всегда передаются по значению. 

Например:
\begin{lstlisting}
    public class Test
    {
     public static void main(String[] args) {
          int x = 5;
          changeValue(x);
          System.out.println(x);  // Output: 5
       }
       
       public static void changeValue(int num) {
          num = 10;
       }
    }
\end{lstlisting}

В этом примере, метод {\bf changeValue()} получает копию значения переменной x, и изменения, внесенные в {\bf num}, не влияют на оригинальную переменную x.

Однако, если переменная является объектом, то передача может быть как по значению, так и по ссылке. Если переменная передается как параметр метода, который изменяет ее состояние, это изменение будет отражено в вызывающем коде, потому что ссылка на объект передается по значению.
\section{Операции над переменными ссылочного типа}
Переменные ссылочного типа в Java хранят ссылки на объекты, а не сами объекты, и операции над такими переменными отличаются от операций над примитивными типами данных.

Присваивание: операция присваивания для переменных ссылочного типа копирует ссылку на объект, а не сам объект. Это означает, что если две переменные ссылочного типа ссылаются на один и тот же объект, изменение объекта через одну переменную отразится на другой переменной.

Пример:
\begin{lstlisting}
    MyClass obj1 = new MyClass();
    MyClass obj2 = obj1;
\end{lstlisting}

Сравнение: операция сравнения для переменных ссылочного типа проверяет, ссылаются ли они на один и тот же объект. Для этого используются операторы {\bf == и !=}. 

Они проверяют, ссылаются ли две переменные на один и тот же объект. Если две переменные ссылочного типа ссылаются на разные объекты, они будут считаться разными.

Пример:
\begin{lstlisting}
    MyClass obj1 = new MyClass();
    MyClass obj2 = new MyClass();
    
    if (obj1 == obj2) {
       System.out.println();
    } else {
       System.out.println();
    }
\end{lstlisting}

Вызов методов: переменные ссылочного типа могут вызывать методы, определенные в объекте, на который они ссылаются. Для этого необходимо использовать оператор ` . `.

Пример:
\begin{lstlisting}
    MyClass obj = new MyClass();
    obj.myMethod();
\end{lstlisting}

Проверка на null: переменные ссылочного типа могут иметь значение null, которое означает, что они не ссылаются ни на один объект. Чтобы проверить, ссылаются ли переменные на null, используйте оператор {\bf==}.

Пример:
\begin{lstlisting}
    MyClass obj = null;
    
    if (obj == null) {
       System.out.println("Obj == null");
    }
\end{lstlisting}

\section{Проверка типа и приведение типов}
В Java каждый объект имеет свой тип, который определяется классом, от которого он был создан. Проверка типа и приведение типов - это важные операции, которые позволяют проверять и изменять типы объектов в Java.

Проверка типа

Проверка типа в Java выполняется оператором {\bf instanceof}. Он проверяет, является ли объект экземпляром определенного класса или его подкласса. Синтаксис оператора {\bf instanceof}:
\begin{lstlisting}
    object instanceof class
\end{lstlisting}

где {\bf object} - объект, тип которого проверяется, а class - класс или интерфейс, экземпляр которого должен быть {\bf object}.

\begin{lstlisting}
    Object obj = "Hello";
    if (obj instanceof String) {
       String str = (String) obj;
       System.out.println(str.toUpperCase());
    }
\end{lstlisting}

В этом примере сначала выполняется проверка типа, используя оператор {\bf instanceof}, чтобы убедиться, что obj является экземпляром класса String. Затем переменная obj приводится к типу String, чтобы выполнить операцию {\bf toUpperCase()}.

Приведение типов

Приведение типов - это операция, которая изменяет тип объекта. В Java приведение типов выполняется с помощью операторов приведения типов.

\begin{lstlisting}
    double d = 3.14159;
    int i = (int) d;
    System.out.println(i);
\end{lstlisting}

В этом примере переменная d приводится к типу int, что приводит к отбрасыванию дробной части числа и присвоению целочисленного значения переменной i.

Приведение типов может быть не безопасным, поэтому необходимо использовать его с осторожностью. 

Если произойдет попытка приведения объекта к несовместимому типу, возникнет исключение {\bf ClassCastException}. Чтобы избежать этой ошибки, перед приведением типов необходимо выполнить проверку типа с помощью оператора {\bf instanceof}.
\section{Объектные классы-обертки примитивных типов}

В Java есть 8 примитивных типов данных: {\bf boolean, byte, short, int, long, float, double} и {\bf char}. Кроме того, в Java есть объектные классы-обертки, которые представляют собой объекты, инкапсулирующие значения примитивных типов.

Эти объектные классы-обертки имеют те же имена, что и соответствующие примитивные типы, но начинаются с заглавной буквы: {\bf Boolean, Byte, Short, Integer, Long, Float, Double} и {\bf Character}.

Объектные классы-обертки часто используются для работы с примитивными типами данных в контексте объектно-ориентированной парадигмы. Они предоставляют некоторые дополнительные функции, которых нет в примитивных типах данных, такие как методы преобразования типов и методы работы со строками.

Пример использования класса-обертки {\bf Integer}:

\begin{lstlisting}
    int x = 10;
    Integer integerObj = Integer.valueOf(x);
    int y = integerObj.intValue();
    System.out.println("x = " + x + ", y = " + y);
\end{lstlisting}

В этом примере переменная x имеет значение типа int, которое затем используется для создания объекта класса-обертки {\bf Integer}. Затем значение типа int извлекается из объекта Integer и присваивается переменной y. Наконец, значения x и y выводятся на экран.

Объектные классы-обертки также позволяют работать с примитивными типами данных в качестве объектов, что может быть удобно в некоторых случаях. Например, они могут быть переданы в методы, требующие объектов, а не примитивных типов данных.

Кроме того, объектные классы-обертки могут быть использованы вместо примитивных типов данных при работе с коллекциями и другими объектами, которые могут хранить только объекты.

Также стоит отметить, что объектные классы-обертки могут использоваться для работы с некоторыми методами, которые требуют объектов. Например, класс {\bf Math} содержит методы для вычисления математических операций, таких как {\bf abs}, {\bf sqrt}, {\bf pow}, и т.д., которые принимают и возвращают значения объектных классов-оберток, таких как {\bf Integer}, {\bf Double}, {\bf Float}, и т.д.

Таким образом, объектные классы-обертки являются удобным инструментом для работы с примитивными типами данных в {\bf Java}, позволяющим работать с ними в контексте объектно-ориентированной парадигмы и предоставляющим дополнительные функции, которых нет в примитивных типах данных.

\newpage % Эта команда начинает новую страницу
\chapter{Идентификаторы.Символы и символьные литералы.Строковый тип данных.Основные кодировки}%
\section{Правила именования переменных в Java и общие соглашения о стиле кодирования}

{\bf Правила именования переменных}

1. Имена переменных должны начинаться с буквы или знака подчеркивания.

2. Имя переменной может содержать буквы, цифры и знаки подчеркивания, но не должно начинаться с цифры.

3. Имя переменной должно быть описательным и понятным, чтобы легко понимать, что она представляет.

4. В Java используется {\bf camelCase} нотация для именования переменных. Первое слово пишется в нижнем регистре, а каждое последующее слово начинается с заглавной буквы.

Пример:
\begin{lstlisting}
    int studentAge;
    double averageGrade;
    String studentName;
\end{lstlisting}

{\bf Общие соглашения о стиле кодирования в Java}

1. Используйте каркасную скобку на новой строке после открывающей скобки. 

Например:
\begin{lstlisting}
    if (condition) {
        // some code
    } else {
        // some code
    }
\end{lstlisting}

2. Используйте отступы в 4 пробела для каждого уровня вложенности. 

Например:
\begin{lstlisting}
    public class MyClass {
        public void myMethod() {
            if (condition) {
                // some code
            } else {
                // some code
            }
        }
    }
\end{lstlisting}

3. Имена классов должны начинаться с заглавной буквы, а слова в названии класса должны быть разделены заглавными буквами (например, "MyClass"). 

Например:
\begin{lstlisting}
    public class MyClass {
        // some code
    }
\end{lstlisting}


4. Имена методов должны начинаться со строчной буквы, а слова в названии метода должны быть разделены заглавными буквами (например, "myMethod"). 

Например:
\begin{lstlisting}
    public class MyClass {
        public void myMethod() {
            // some code
        }
    }
\end{lstlisting}

5. Используйте комментарии для описания кода, чтобы облегчить чтение и понимание кода. 

6. Используйте верхний регистр для именования констант.

Пример:
\begin{lstlisting}
    public class MyClass {
        public static final int MAX_VALUE = 100;
        public static final String MY_STRING = "Hello, World!";
    }
\end{lstlisting}

7. Используйте строго типизированные коллекции вместо общих типов (например, использование List вместо ArrayList).

Пример:
\begin{lstlisting}
    List<String> names = new ArrayList<>();
    names.add("Alice");
    names.add("Bob");
    names.add("Charlie");
\end{lstlisting}

8. Избегайте слишком длинных строк кода. Рекомендуемая максимальная длина строки - 80 символов.

\section{Символьный тип в Java}

В Java символьный тип (char) используется для представления символов Unicode. Символы могут быть буквами, цифрами, знаками препинания и другими символами, которые вы можете ввести с клавиатуры.

Символьный тип в Java имеет размер 16 бит (или 2 байта) и может хранить любой символ из набора Unicode, который включает в себя более чем 120 000 символов. Каждый символ в Unicode представлен уникальным номером, называемым кодовой точкой.

Для создания символьной переменной в Java используется ключевое слово char. Например, мы можем объявить переменную ch следующим образом:

\begin{lstlisting}
    char ch = 'A';
\end{lstlisting}

В этом примере мы объявили переменную ch типа char и присвоили ей значение 'A'. Обратите внимание, что символы в Java заключаются в одинарные кавычки.

Мы можем также использовать числовое значение Unicode для инициализации символьной переменной. Например, следующий код присваивает переменной ch символ с кодовой точкой Unicode 65, что соответствует символу 'A':

\begin{lstlisting}
    char ch = 65;
\end{lstlisting}

В Java также поддерживаются специальные символы, которые начинаются с обратной косой черты ("\"). Например, символ {\bf \n }представляет собой перевод строки, а символ {\bf \t }представляет табуляцию. Другие специальные символы включают {\bf \b } (забой), {\bf \r }(возврат каретки) и \\ (обратный слеш).


Примеры использования символьных переменных в Java:

\begin{lstlisting}
    char ch1 = 'A';         // Declaring a variable and assigning a value
    char ch2 = 65;          // Initializing a variable with a numeric value
    char ch3 = '\n';        // Line break character
    char ch4 = '\t';        // Tab character
    String message = "Hello, " + ch1 + ch2 + ch3 + ch4 + "world!";   // Concatenation of characters in a string
\end{lstlisting}

Символьный тип в Java является важным типом данных, который позволяет работать со множеством символов, используемых в программах на Java.

\section{Примитивы для работы с символами}

В Java символы представлены примитивным типом char, который используется для хранения одиночных символов Unicode. char занимает 2 байта (16 бит) памяти и может хранить символы из любых языков, включая китайский, японский, кириллицу и т.д.

Определение символа производится в одинарных кавычках. 

Например:
\begin{lstlisting}
    char c = 'A';
\end{lstlisting}

Java также есть целочисленный тип int, который можно использовать для представления символов Unicode. В этом случае символы должны быть представлены в виде числовых значений Unicode. 
 
Например:
\begin{lstlisting}
    int i = 65; // Unicode for the character 'A'
    char c = (char)i; // symbol 'A'
\end{lstlisting}

Однако, использование целочисленных типов для работы с символами не всегда удобно и эффективно, так как целочисленные операции требуют большей памяти и производительности, чем операции над символами типа char.

Для работы с символами в Java также можно использовать классы-обертки, такие как Character, {\bf StringBuffer} и {\bf StringBuilder}. 

Класс Character содержит различные методы для работы с символами, включая проверку на то, является ли символ буквой, цифрой или пробелом, и методы преобразования символов между регистрами. Классы {\bf StringBuffer} и {\bf StringBuffer} также предоставляют методы для работы со строками и символами, но {\bf StringBuffer} является потокобезопасным, тогда как {\bf StringBuffer} не обеспечивает потокобезопасность и обычно более быстрый, если не требуется многопоточный доступ.

Также важно отметить, что символы в Java используются не только для работы с текстом и строками, но и для многих других целей. Например, символы можно использовать для представления числовых значений, специальных символов и т.д.

Некоторые из наиболее распространенных примитивных типов данных, используемых для работы с символами в Java, перечислены ниже:

- char: 2-байтовый беззнаковый целочисленный тип, который используется для представления символов Unicode.

- byte: 1-байтовый знаковый целочисленный тип, который может быть использован для представления символов ASCII.

- short: 2-байтовый знаковый целочисленный тип, который также может быть использован для представления символов Unicode.

- int: 4-байтовый знаковый целочисленный тип, который может быть использован для представления символов Unicode или целочисленных значений Unicode.

\section{Кодировка Unicode}

Кодировка Unicode - это стандарт для представления текста в компьютерных системах, который позволяет представлять символы всех языков мира, используя единый набор кодовых точек. Java поддерживает Unicode в полной мере, и в языке определены типы данных, которые могут использоваться для работы с символами Unicode.

В Java символы Unicode представляются типом `char`, который занимает 2 байта памяти и может хранить значения от 0 до 65535. Однако Unicode использует намного больше кодовых точек, чем это может вместить тип `char`. Поэтому Java предоставляет другой тип данных, `String`, который может содержать последовательность `char` и позволяет представлять любой символ Unicode.

Java использует Unicode для работы с текстом на всех уровнях, включая ввод-вывод, строковые литералы, имена переменных и т.д. Например, при чтении файла в Java символы Unicode будут автоматически декодироваться из байтового потока в соответствующую последовательность `char`, используя заданную кодировку.

Java также предоставляет множество методов для работы с символами Unicode, включая методы преобразования регистра, методы определения типа символа, методы работы со строками и многие другие.

В Java также есть типы, такие как {\bf Character} и {\bf StringBuilder}, которые могут использоваться для работы с символами Unicode. 

Тип {\bf Character} предоставляет множество статических методов для работы с символами, таких как определение типа символа, преобразование регистра, сравнение символов и т.д. 

Тип {\bf StringBuilder} предоставляет возможность конструировать и изменять строки на основе символов Unicode.

Кроме того, Java предоставляет поддержку регулярных выражений для работы со строками, включая символы Unicode. Регулярные выражения в Java используют синтаксис, который позволяет использовать широкий набор символов Unicode для поиска и замены текста в строках.

В целом, использование кодировки Unicode в Java обеспечивает поддержку работы с текстом на различных языках и культурах, и является важным аспектом международной поддержки и мультиязычности в разработке программного обеспечения.

\section{Преобразования символов}

В Java существуют несколько способов преобразования символов и строк. Рассмотрим некоторые из них:

{\bf Преобразование символа в число:}

В Java тип {\bf char} является примитивным типом данных, который может содержать только один символ. В то же время, тип {\bf int} представляет целое число. Для преобразования символа в число можно использовать оператор приведения типа:

\begin{lstlisting}
    char ch = 'A';
    int num = (int) ch;
\end{lstlisting}

В этом примере переменной ch присваивается символ 'A', а затем его значение преобразуется в число с помощью оператора приведения типа, и результат сохраняется в переменной {\bf num}.

{\bf Преобразование числа в символ:}

Для преобразования числа в символ используется метод {\bf char}, который принимает в качестве аргумента целочисленное значение кодовой точки символа:

\begin{lstlisting}
    int num = 65;
    char ch = (char) num;
\end{lstlisting}

В этом примере переменной {\bf num} присваивается значение 65, которое соответствует кодовой точке символа 'A'. Затем значение преобразуется в символ с помощью оператора приведения типа, и результат сохраняется в переменной ch.

{\bf Преобразование строки в символы:}

В Java строка является последовательностью символов. Чтобы преобразовать строки в массив символов используется метод {\bf toCharArray()}:

\begin{lstlisting}
    String str = "Hello";
    char[] chars = str.toCharArray();
\end{lstlisting}

В этом примере переменной {\bf str} присваивается строка $"Hello"$, а затем с помощью метода {\bf toCharArray()} строка преобразуется в массив символов, и результат сохраняется в переменной {\bf chars}.

{\bf Преобразование символов в строку:}

Для преобразования массива символов в строку можно использовать конструктор класса {\bf String}:

\begin{lstlisting}
    char[] chars = {'H', 'e', 'l', 'l', 'o'};
    String str = new String(chars);
\end{lstlisting}

В этом примере переменной chars присваивается массив символов, затем с помощью конструктора класса String массив символов преобразуется в строку, и результат сохраняется в переменной {\bf str}.

Кроме того, в Java существует множество других методов и классов для работы с символами и строками, таких как {\bf StringBuilder}, {\bf StringBuffer}, {\bf StringTokenizer} и многие другие, которые могут использоваться для различных задач, связанных с обработкой символов и строк.

\newpage % Эта команда начинает новую страницу
\chapter{Основы ввода-вывода и основные библиотечные классы}

\section{Основные классы для организации ввода-вывода в Java}

В Java существует несколько классов, которые используются для организации ввода-вывода. 

Класс {\bf System.in}: Этот класс используется для чтения данных, вводимых с клавиатуры. Для чтения данных из этого класса используется объект класса Scanner. 

Пример:

\begin{lstlisting}
    import java.util.Scanner;
    
    public class Main {
        public static void main(String[] args) {
            Scanner scanner = new Scanner(System.in);
            System.out.print("Enter your name: ");
            String name = scanner.nextLine();
            System.out.println("Hello, " + name + "!");
        }
    }
\end{lstlisting}

Класс {\bf System.out}: Этот класс используется для вывода данных на экран. Для вывода данных в этот класс используется метод System.out.print или System.out.println.
\newpage
Пример:

\begin{lstlisting}
public class Main {
    public static void main(String[] args) {
        System.out.print("Hello, ");
        System.out.println("World!");
    }
}
\end{lstlisting}

Класс {\bf File}: Этот класс используется для работы с файлами. Для чтения данных из файла используется класс FileInputStream, а для записи данных в файл используется класс FileOutputStream. 

Пример:

\begin{lstlisting}
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class Main {
    public static void main(String[] args) {
        try {
            File file = new File("test.txt");
            FileOutputStream fos = new FileOutputStream(file);
            String data = "Hello, world!";
            fos.write(data.getBytes());
            fos.close();
            
            FileInputStream fis = new FileInputStream(file);
            byte[] bytes = new byte[(int) file.length()];
            fis.read(bytes);
            fis.close();
            System.out.println(new String(bytes));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
\end{lstlisting}

Класс {\bf Scanner}: Этот класс используется для чтения данных из разных источников, включая файлы и строковые буферы. 

Пример:

\begin{lstlisting}
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        String data = "1 2 3 4 5";
        Scanner scanner = new Scanner(data);
        while (scanner.hasNext()) {
            int number = scanner.nextInt();
            System.out.println(number);
        }
    }
}
\end{lstlisting}

Класс {\bfPrintWriter}: Этот класс используется для вывода данных в поток вывода. Для вывода данных в этот класс используется метод {\bf print()} или {\bf println()}. 

Пример:

\begin{lstlisting}
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;

public class Main {
    public static void main(String[] args) {
        try {
            PrintWriter pw = new PrintWriter(new FileWriter("output.txt"));
            pw.println("Hello, world!");
            pw.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
\end{lstlisting}

\section{Чтение с консоли и вывод в консоль}

Чтение с консоли и вывод в консоль - это часто используемые операции при работе с Java-приложениями. В Java для этого используются стандартные потоки ввода-вывода - System.in и System.out.

Чтение с консоли в Java осуществляется с помощью класса {\bf Scanner} или {\bf BufferedReader}. 

Пример чтения ввода с помощью класса Scanner:

\begin{lstlisting}
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter your name: ");
        String name = scanner.nextLine();
        System.out.println("Hello, " + name + "!");
        scanner.close();
    }
}
\end{lstlisting}

В данном примере создается объект класса Scanner, передав ему в качестве аргумента объект стандартного потока ввода - System.in. Затем используется метод {\bf nextLine()} для чтения ввода в виде строки. В конце закрывается объект класса Scanner с помощью метода {\bf close()}.

Также можно использовать класс {\bf BufferedReader} для чтения ввода с консоли.

Пример кода:

\begin{lstlisting}
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) {
        try {
            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
            System.out.print("Enter your name: ");
            String name = reader.readLine();
            System.out.println("Hello, " + name + "!");
            reader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
\end{lstlisting}

В этом примере создается объект класса {\bf BufferedReader}, передав ему в качестве аргумента объект стандартного потока ввода - System.in. Затем используется метод {\bf readLine()} для чтения ввода в виде строки.
Вывод в консоль в Java осуществляется с помощью объекта System.out.

Пример:

\begin{lstlisting}
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello, world!");
    }
}
\end{lstlisting}

В этом примере используется метод {\bf println()} объекта System.out, чтобы вывести строку "Hello, world!" в консоль. Метод {\bf println()} также добавляет символ перевода строки в конце выводимой строки.

Также можно использовать метод print(), который выводит строку без добавления символа перевода строки в конце. 

Пример:

\begin{lstlisting}
public class Main {
    public static void main(String[] args) {
        System.out.print("Hello, ");
        System.out.print("world!");
    }
}
\end{lstlisting}

В этом примере используется метод {\bf print()} дважды, чтобы вывести строки "Hello, " и "world!" без добавления символа перевода строки.


\section{Преобразование строки в другие типа данных}

В Java для преобразования строковых данных в другие типы данных используются методы классов-оберток (Integer, Double, Boolean, и т.д.) и методы класса String.

Для преобразования строки в целочисленный тип (int) можно использовать метод {\bf parseInt()} класса Integer. 

Пример:

\begin{lstlisting}
String str = "123";
int num = Integer.parseInt(str);
\end{lstlisting}

В данном примере создается строка "123", затем преобразовывается в целое число с помощью метода {\bf parseInt()} класса Integer. Результат присвоили переменной {\bf num}.

Если строка не может быть преобразована в целочисленный тип, то метод {\bf parseInt()} выбрасывает исключение {\bf NumberFormatException}. Для этого рекомендуется обернуть вызов метода в блок {\bf try-catch}.

Аналогичным образом можно преобразовать строку в другие числовые типы данных, например double, long и т.д. Для этого используются методы {\bf parseDouble()}, {\bf parseLong()} и т.д. соответствующих классов-оберток.

Также можно использовать метод {\bf valueOf()} класса Integer для преобразования строковых данных в целочисленный тип. Однако в отличие от метода {\bf parseInt()}, метод {\bf valueOf()} возвращает объект Integer. 

Пример:

\begin{lstlisting}
String str = "123";
Integer num = Integer.valueOf(str);
\end{lstlisting}

Для преобразования строки в логический тип (boolean) можно использовать метод {\bf parseBoolean()} класса Boolean. 

Пример:

\begin{lstlisting}
String str = "true";
boolean bool = Boolean.parseBoolean(str);
\end{lstlisting}

Метод {\bf parseBoolean()} принимает в качестве аргумента "true" или "false" (регистр букв не имеет значения) и возвращает соответствующее логическое значение.

Также можно использовать метод {\bf valueOf()} класса Boolean для преобразования строковых данных в логический тип. Однако в отличие от метода {\bf parseBoolean()}, метод {\bf valueOf()} возвращает объект Boolean.

Если нужно преобразовать объект String в тип char, то можно использовать метод {\bf charAt()} класса String. 

Пример:

\begin{lstlisting}
String str = "abc";
char ch = str.charAt(0);
\end{lstlisting}

В данном примере создается строка "abc", затем преобразовывается первый символ в тип char с помощью метода {\bf charAt()}. Результат присвоили переменной ch.

Также можно использовать метод {\bf toCharArray()}, чтобы преобразовать строку в массив символов (char[]).

\section{Задачи обработки строк}

Обработка строк является одним из наиболее частых заданий в программировании на Java. 

{\bf Самые распространенные задачи:}

{\bf 1. Разделение строки на подстроки}

Часто бывает необходимо разделить строку на подстроки по определенному разделителю, например пробелу или запятой. Для этого можно использовать метод {\bf split()} класса {\bf String}. 
\newpage
Пример:

\begin{lstlisting}
String str = "one,two,three";
String[] parts = str.split(",");
\end{lstlisting}

В данном примере создается $"one,two,three"$, затем разделяем ее на массив строк, используя запятую в качестве разделителя. Результат присвоили переменной parts, которая теперь содержит массив из трех строк "one", "two" и "three".

{\bf 2. Объединение строк}

Для объединения двух или более строк можно использовать оператор $"+"$ или метод {\bf concat()} класса String. 

Пример:

\begin{lstlisting}
String str1 = "Hello";
String str2 = "world!";
String result1 = str1 + " " + str2; // use opetator +
String result2 = str1.concat(" ").concat(str2); // use method concat()
\end{lstlisting}

В данном примере объединяем две строки "Hello" и "world!", используя оператор $"+"$ и метод {\bf concat()}. Результаты присвоили переменным {\bf result1} и {\bf result2} соответственно.

{\bf 3. Замена подстроки в строке}

Часто необходимо заменить одну подстроку на другую в строке. Для этого можно использовать метод {\bf replace()} класса String. 

\newpage
Пример:

\begin{lstlisting}
String str = "Java is cool!";
String newStr = str.replace("Java", "Python");
\end{lstlisting}

В данном примере создается строка "Java is cool!", затем заменяем подстроку "Java" на "Python". Результат присваиваем переменной newStr, которая теперь содержит строку "Python is cool!".

{\bf Удаление пробелов в начале и конце строки}

Для удаления пробелов в начале и конце строки можно использовать метод {\bf trim()} класса String. 

Пример:

\begin{lstlisting}
String str = "   Hello, world!   ";
String newStr = str.trim();
\end{lstlisting}

В данном примере создается " Hello, world! ", затем убираем пробелы в начале и конце строки с помощью метода trim(). Результат присвоили переменной {\bf newStr}, которая теперь содержит строку "Hello, world!".

\section{Форматированный ввод и вывод}

Форматированный ввод и вывод в Java позволяет выводить и вводить данные с определенным форматированием. Это может быть полезно, например, для вывода таблиц или чисел с заданным числом знаков после запятой.

Для форматированного вывода можно использовать метод {\bf printf()} класса {\bf PrintStream} или {\bf System.out}, который работает аналогично функции printf() в языке Си. Он позволяет выводить данные в заданном формате, используя специальные символы для указания типа выводимых данных и их форматирования.

Синтаксис метода {\bf printf()} выглядит следующим образом:

\begin{lstlisting}
System.out.printf("format", arguments);
\end{lstlisting}

Здесь $format$ - это строка, содержащая специальные символы для форматирования вывода, а аргументы - это переменные, значения которых будут подставлены в соответствующие места в строке $format$.

Например, для вывода числа с заданным числом знаков после запятой можно использовать следующий код:

\begin{lstlisting}
double x = 3.14159265359;
System.out.printf("%.2f", x);
\end{lstlisting}

%ОШИБКААААА !!!!!!! Спросить!%
Здесь   "%f" - это специальный символ для вывода числа с плавающей точкой, а "%.2f" - это формат, указывающий, что число должно быть выведено с двумя знаками после запятой.

Для форматированного ввода можно использовать класс {\bf Scanner}, который позволяет считывать данные из стандартного ввода или файла с использованием специальных символов для указания типа вводимых данных и их форматирования.

Синтаксис класса {\bf Scanner} выглядит следующим образом:

\begin{lstlisting}
Scanner scanner = new Scanner(System.in);
type_data variable = scanner.nextType_data();
\end{lstlisting}

Здесь nextTypedata() - это метод объекта ${\bf Scanner}$, который считывает следующее значение заданного типа данных из входного потока.

Например, для считывания числа с плавающей точкой с заданным числом знаков после запятой можно использовать следующий код:

\begin{lstlisting}
Scanner scanner = new Scanner(System.in);
double x = scanner.nextDouble();
\end{lstlisting}

Здесь {\bf nextDouble()} - это метод объекта $Scanner$, который считывает следующее значение типа double из входного потока.

\section{Базовые библиотеки Java API}

Java API ($Application Programming Interface$) - это набор стандартных классов и интерфейсов,поставляющиеся с JDK и могут использоваться для разработки Java-приложений. Java API включает в себя множество базовых библиотек, которые обеспечивают широкий набор функциональных возможностей для работы с различными типами данных, структурами данных, файлами, сетью и многими другими аспектами.

{\bf Некоторые из базовых библиотек Java API}:

{\bf java.lang} - базовая библиотека, включающая основные классы и интерфейсы, используемые в Java. 

Некоторые из них: Object, String, Integer, Boolean, Math и др.

{\bf java.util} - библиотека, содержащая различные утилиты для работы с коллекциями, датами, временем и другими структурами данных. 

Некоторые из классов: List, Set, Map, Date, Calendar, TimeZone и др.

{\bf java.io} - библиотека, обеспечивающая работу с потоками ввода-вывода. 

Некоторые из классов: InputStream, OutputStream, Reader, Writer, File, RandomAccessFile и др.

{\bf java.net} - библиотека, позволяющая работать с сетью и протоколами связи. 

Некоторые из классов: URL, URLConnection, InetAddress, ServerSocket, Socket и др.

{\bf java.awt и javax.swing} - библиотеки, используемые для создания графического интерфейса пользователя. 

Некоторые из классов: Frame, Dialog, Panel, Button, TextField, JFrame, JDialog, JPanel, JButton, JTextField и др.

{\bf java.sql} - библиотека, позволяющая работать с базами данных.

Некоторые из классов: Connection, Statement, PreparedStatement и др.

{\bf java.security} - библиотека, обеспечивающая работу с безопасностью и шифрованием данных. 

Некоторые из классов: Key, KeyPair, KeyPairGenerator, Cipher и др.

{\bf java.nio} - библиотека, позволяющая работать с неблокирующими операциями ввода-вывода. 

Некоторые из классов: ByteBuffer, CharBuffer, Selector, Channel и др.

Кроме того, в Java API существует еще множество других библиотек, которые обеспечивают работу с различными аспектами разработки приложений, такими как XML, сериализация, рефлексия, синхронизация, логирование и многими другими.

Для использования любой библиотеки {\bf Java API} необходимо подключить ее в свой проект. Для этого можно воспользоваться инструментом управления зависимостями, таким как $Maven$ или $Gradle$, или же добавить необходимые JAR-файлы в свой проект вручную.

{\bf Java API} является одним из ключевых инструментов для разработки Java-приложений. Он обеспечивает широкий набор функциональных возможностей, которые позволяют разработчикам создавать мощные и эффективные приложения для различных целей. Большое количество документации и общедоступных примеров использования библиотек Java API позволяют легко овладеть этим инструментом и использовать его в своих проектах.

\section{Пакеты java.lang, java.util}

Пакет {\bf java.lang} является одним из базовых пакетов Java и содержит классы и интерфейсы, которые являются часто используемыми в языке Java. В этом пакете находятся такие классы, как String, Object, Math, Integer, Boolean и многие другие.

\begin{itemize} 
  \item Класс {\bf String} является одним из самых часто используемых классов в Java. Он представляет собой строку символов и содержит множество методов для работы с этими строками, таких как charAt(), concat(), indexOf(), substring() и многих других.
  \item  Класс {\bf Object} является базовым классом для всех классов в Java. Он содержит методы, которые могут использоваться в любом классе, такие как equals(), hashCode(), toString() и другие.
  \item Класс {\bf Math} содержит методы для выполнения математических операций, таких как sqrt(), sin(), cos(), max(), min() и многие другие.
  \item Класс {\bf Integer} представляет целочисленные значения и содержит методы для работы с этими значениями, как parseInt(), toString(), valueOf() и другие.
  \item Класс {\bf Boolean} представляет булевые значения true и false и содержит методы для работы с этими значениями, как parseBoolean(), toString() и другие.
  \item Пакет {\bf java.util} содержит классы и интерфейсы для работы с коллекциями, датами, временем, регулярными выражениями и многими другими возможностями. В этом пакете находятся такие классы, как ArrayList, HashMap, LinkedList, Date, Calendar, Scanner и многие другие.
  \item Классы коллекций, такие как {\bf ArrayList}, {\bf LinkedList}, {\bf HashMap} и многие другие, представляют структуры данных для хранения и управл ния группой объектов. Они обеспечивают множество методов для работы с этими коллекциями, таких как add(), remove(), size(), contains() и многие другие.
  \item Классы даты и времени, такие как {\bf Date} и {\bf Calendar}, представляют методы для работы с датами и временем. Они позволяют выполнять операции, такие как получение текущей даты и времени, добавление или вычитание определенного количества дней, часов, минут или секунд и многие другие.
  \item Класс {\bf Scanner} также предоставляет методы для чтения других типов данных, таких как числа с плавающей точкой, строки, булевы значения и многие другие.
\end{itemize}

\newpage
\chapter{Структура класса}
\section{Концепция, синтаксис и описание класса в Java}
Концепция класса в Java относится к объектно-ориентированной парадигме программирования, которая используется в Java и многих других языках программирования. Класс является основным элементом объектно-ориентированного программирования и определяет свойства и методы объекта.

Синтаксис класса в Java выглядит следующим образом:

\begin{lstlisting}
[modificators] class ClassName [extends ParentClass] [implements Interface1, Interface2, ...] {
  // Properties (fields) classes
  [modificators] Type NameProperty1 [= Value1];
  [modificators] Type NameProperty2 [= Value2];
  // Class methods
  [modificators] ReturnedValueType NameMethod1(Parameters) {
    // Method body
  }
  [modificators] ReturnedValueType NameMethod2(Parameters) {
    // Method body
  }
}
\end{lstlisting}

Здесь modificators - это ключевые слова, которые определяют доступность класса и его членов (свойств и методов). Например, public, private и protected. ClassName - это имя класса, которое должно быть уникальным в пределах пакета. ParentClass - это класс, от которого наследуется текущий класс (не обязательно). Interface1, Interface2, ... - это список интерфейсов, которые реализует текущий класс (не обязательно).

В теле класса находятся его свойства (поля) и методы. Свойства определяют данные, которые хранятся в объекте класса, а методы определяют поведение объекта.

Свойства и методы могут иметь модификаторы доступа, такие как public, private, protected или без модификаторов. Модификатор public означает, что свойство или метод доступен из любой части программы, модификатор private - что свойство или метод доступен только внутри класса, модификатор protected - что свойство или метод доступен внутри класса и его подклассов, и без модификатора - что свойство или метод доступен внутри пакета, в котором находится класс.

Тип возвращаемого значения метода указывается перед именем метода, а параметры метода указываются в скобках после имени метода.

Классы в Java могут использоваться для создания объектов, то есть экземпляров класса. Для создания объекта класса используется оператор new. 

\newpage
Например, для создания объекта класса Person можно написать следующий код:

\begin{lstlisting}
Person person = new Person();
\end{lstlisting}

В этом примере $person$ - это переменная, которая ссылается на объект класса Person, созданный оператором new.

Объекты класса могут использоваться для вызова его методов и обращения к его свойствам. Например, если у класса Person есть метод {\bf getName()}, который возвращает имя объекта Person, то можно вызвать его следующим образом:

\begin{lstlisting}
String name = person.getName();
\end{lstlisting}

В этом примере переменная $name$ содержит имя объекта $person$, которое было получено вызовом метода {\bf getName()}.

Классы в Java также могут иметь статические члены, которые принадлежат классу, а не объектам класса. Статические свойства и методы можно вызывать без создания объекта класса, используя имя класса. 

Например, если у класса Person есть статическое свойство count, которое содержит количество созданных объектов Person, то его можно вызвать следующим образом:

\begin{lstlisting}
int count = Person.count;
\end{lstlisting}

Здесь переменная $count$ содержит количество созданных объектов класса $Person$.

В Java также существует концепция пакетов, которые являются логической группой классов. Классы внутри пакета могут обращаться друг к другу без использования ключевого слова import. Пакеты могут использоваться для управления пространством имен и для организации кода в более логические блоки. Классы, которые находятся в одном пакете, могут иметь доступ к своим членам (свойствам и методам) без использования модификаторов доступа.

В общем, классы определяют свойства и методы объекта и могут использоваться для создания объектов и управления поведением программы.

\section{Поля класса, конструкторы, методы}

{\bf Поля класса} ($class fields$) - это переменные, которые определены в классе и доступны для использования всеми методами класса. Поля класса могут иметь различные модификаторы доступа, такие как $public$, $private$ или $protected$, что позволяет контролировать их доступность извне класса.

Пример объявления поля класса:

\begin{lstlisting}
public class Person {
    private String name; // class field
}
\end{lstlisting}
\newpage
{\bf Конструкторы} ($constructors$) - это специальные методы, которые вызываются при создании объекта класса с помощью оператора {\bf new}. Конструкторы используются для инициализации свойств объекта и выполнения других действий, которые необходимы при создании объекта. Конструкторы всегда имеют то же имя, что и класс, в котором они определены, и не имеют возвращаемого значения.

Пример объявления конструктора:

\begin{lstlisting}
public class Person {
    private String name;

    public Person(String name) { // constructor
        this.name = name;
    }
}
\end{lstlisting}

В этом примере $Person$(String name) - это конструктор класса $Person$, который инициализирует поле name значением аргумента name.

{\bf Методы} (methods) - это функции, которые определены в классе и могут быть вызваны из объекта класса. Методы могут принимать аргументы и возвращать значения, которые могут использоваться для управления поведением программы.

Пример объявления метода:

\begin{lstlisting}
public class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }

    public void sayHello() { // method
        System.out.println("Hello, my name is " + this.name);
    }
}
\end{lstlisting}

В этом примере {\bf sayHello()} - это метод класса $Person$, который выводит сообщение с именем объекта $Person$.

Методы могут иметь различные модификаторы доступа, такие как $public$, $private$ или $protected$, что позволяет контролировать их доступность извне класса. Методы также могут быть статическими ($static$), что означает, что они принадлежат классу, а не объекту, и могут быть вызваны без создания объекта класса.

Пример объявления статического метода:

\begin{lstlisting}
public class Person {
    private String name;
    private static int count;

    public Person(String name) {
        this.name = name;
        count++;
    }

    public static int getCount() { // static method
        return count;
    }
}
\end{lstlisting}

В этом примере {\bf getCount()} - это статический метод класса $Person$, который возвращает количество созданных объектов класса $Person$.

В целом, поля класса, конструкторы и методы являются основными элементами класса в Java и позволяют определять свойства и поведение объекта. Они могут использоваться для создания

\section{Модификаторы видимости}

В языке программирования Java существуют 4 модификатора видимости, которые определяют уровень доступности классов, методов и переменных внутри и вне класса:

\begin{enumerate} 
  \item {\bf public:} Объекты, классы и методы с модификатором $public$ доступны из любого места в программе. 
  Этот модификатор является самым открытым и наиболее часто используется. 
  
  Пример использования:

\begin{lstlisting}
public class MyClass {
   public int myField;
   public void myMethod() {
      // code
   }
}
\end{lstlisting}

  \item {\bf private:} Объекты, классы и методы с модификатором private доступны только внутри того же класса, где они были определены. Этот модификатор является самым закрытым и используется, когда необходимо скрыть реализацию от других классов. 
  
Пример использования:

\begin{lstlisting}
public class MyClass {
   private int myField;
   private void myMethod() {
      // code
   }
}
\end{lstlisting}
  \item {\bf protected:} Объекты, классы и методы с модификатором protected доступны только внутри того же класса, где они были определены, а также внутри подклассов этого класса и внутри того же пакета. Этот модификатор используется для реализации наследования и защиты от изменений извне. 
  
  Пример использования:
\begin{lstlisting}
public class MyClass {
    protected int myField;
    protected void myMethod() {
        // code
    }
}
\end{lstlisting}

\item {\bf default} ($package-private$){\bf :} Объекты, классы и методы с модификатором доступа по умолчанию доступны только внутри того же пакета, где они были определены. Этот модификатор используется, когда необходимо скрыть реализацию от других пакетов. 

Пример использования:
\begin{lstlisting}
class MyClass {
   int myField;
   void myMethod() {
      // code
   }
}
\end{lstlisting}
\end{enumerate}

Модификаторы доступа используются для определения доступности классов, методов и переменных внутри и вне класса. Правильное использование модификаторов доступа помогает обеспечить безопасность и удобство взаимодействия между классами в программе.
\end{document}% Эта команда завершает рабочий (исходный) файл электронного учебника