\newpage
\chapter{Многопоточность}

\section{Концепция многопоточного программирования}

\textbf{Многопоточность} — это свойство платформы (операционной системы, виртуальной машины или приложения), позволяющее выполнять один процесс параллельно в несколько потоков. Например, если компьютер обладает несколькими процессорами или ядрами, то тогда он может разделить их обязанности: одна группа выполняет одну задачу, в то время как вторая — совершенно другую. Также некоторые приложения могут посылать запрос к серверу и одновременно отображать всю информацию в графическом интерфейсе — всё благодаря тому, что эти процессы разделены в отдельные \textbf{потоки}.

\textbf{Многопоточное программирование} — это концепция, позволяющая программе разделять свои ресурсы в отдельные потоки, которые затем будут выполнять свои задачи. Многие языки программирования позволяют выполнять данные условия (например, C++), и одним из таких языков является Java. Данный язык для потоков использует специальные классы — \verb|Thread|.

\section{Класс потока (Thread)}

Как и положено всем классам, для выполнения своих задач необходимо создать объект данного класса. Некоторые потоки создаются по умолчанию — например, при запуске программы создаётся \textbf{главный поток}, от которого затем образуются \textbf{дочерние потоки}.

Взглянем на программу, которая получает главный поток и выводит основную информацию о нём:

\begin{lstlisting}
public static void main(String[] args) {
         
    Thread t = Thread.currentThread();
    System.out.println(t.getName()); // main
    System.out.println(t); // Thread[main,5,main]
}
\end{lstlisting}

Для получения текущего потока используется функция \verb|currentThread()| — она создаёт объект класса \verb|Thread|, который содержит исполняемый в данный момент поток. С этим потоком можно взаимодействовать с помощью различных функций, как то:

\begin{enumerate}
    \item \verb|getName()| — получение имени потока (для основного потока — \verb|main|;
    \item \verb|setName(String name)| — установка имени потоку вручную;
    \item \verb|getPriority()| — получение приоритета потока;
    \item \verb|setPriority(int priority)| — установка приоритета — показателя того, насколько вероятней этот поток будет выбран среди всех остальных потоков. Обычно приоритет находится в промежутке от 1 до 10, по умолчанию равен 5;
    \item \verb|isAlive()|: возвращает \verb|true|, если поток активен;
    \item \verb|isInterrupted()|: возвращает \verb|true|, если поток был прерван;
    \item \verb|join()|: ожидает завершение потока;
    \item \verb|run()|: определяет точку входа в поток;
    \item \verb|sleep()|: приостанавливает поток на заданное количество миллисекунд;
    \item \verb|start()|: запускает поток, вызывая его метод \verb|run()|
\end{enumerate}

Также поток можно сразу вывести в консоль вывода — тогда в ней будет надпись вида \verb|Thread(threadName, priority, groupName)|, где каждая из переменная означает имя потока, его приоритет, а также имя группы потоков, к которой он принадлежит, соответственно.

Для создания потока необходимо использовать пользовательские классы, который будут наследоваться либо от \verb|Thread|, либо от \verb|Runnable|. Первый класс является наиболее полным представителем потоков в Java со всеми необходимыми функциями, в то время как \verb|Runnable| представляет собой лишь интерфейс с единственным переопределяемым методом \verb|run()|, куда и должна заноситься вся логика при запуске потока.

\verb|Thread|:

\begin{lstlisting}
class JThread extends Thread {
      
    JThread(String name){
        super(name);
    }
      
    public void run(){
          
        System.out.printf("%s started... \n", Thread.currentThread().getName());
        try{
            Thread.sleep(500);
        }
        catch(InterruptedException e){
            System.out.println("Thread has been interrupted");
        }
        System.out.printf("%s fiished... \n", Thread.currentThread().getName());
    }
}
  
public class Program {
  
    public static void main(String[] args) {
          
        System.out.println("Main thread started...");
        new JThread("JThread").start();
        System.out.println("Main thread finished...");
    }
}
\end{lstlisting}

\verb|Runnable|:

\begin{lstlisting}
class MyThread implements Runnable {
      
     
    public void run(){
          
        System.out.printf("%s started... \n", Thread.currentThread().getName());
        try{
            Thread.sleep(500);
        }
        catch(InterruptedException e){
            System.out.println("Thread has been interrupted");
        }
        System.out.printf("%s finished... \n", Thread.currentThread().getName());
    }
} 
  
public class Program {
  
    public static void main(String[] args) {
          
        System.out.println("Main thread started...");
        Thread myThread = new Thread(new MyThread(),"MyThread");
        myThread.start();
        System.out.println("Main thread finished...");
    }
}
\end{lstlisting}

\section{Прерывание потока. Жизненный цикл потока}

Иногда необходимо создавать бесконечный поток — например, для сервера, прослушивающего порт для получения определённых данных. В некоторых случаях данный поток также необходимо прерывать, и для этого необходимо рассмотреть механизм завершения потока.

Одним из вариантов считается создания отдельной переменной булевого типа, которая будет проверять, необходимо ли завершать данный поток (по умолчанию она равна \verb|false|). Изначально логика потока заключена в цикл, зависящей от этой переменной.  При поступлении события (например, после истечения времени или получения необходимых данных) она меняет своё состояние на \verb|true|, и при следующей итерации потока она выводит процесс из цикла и прекращает работу потока.

Тем не менее, Java предлагает встроенный механизм прерывания — метод \verb|interrupt()|. При его вызове поток получит статус "прерван", но при этом он НЕ будет остановлен — дальнейшую логику необходимо определять самим разработчикам. Например, мы можем прервать поток, а потом проверить его при помощи ещё одно метода, \verb|isInterrupted()|:

\begin{lstlisting}
class JThread extends Thread {
      
    JThread(String name){
        super(name);
    }
    public void run(){
          
        System.out.printf("%s started... \n", Thread.currentThread().getName());
        int counter=1;
        while(!isInterrupted()){
             
            System.out.println("Loop " + counter++);
        }
        System.out.printf("%s finished... \n", Thread.currentThread().getName());
    }
}
public class Program {
  
    public static void main(String[] args) {
          
        System.out.println("Main thread started...");
        JThread t = new JThread("JThread");
        t.start();
        try{
            Thread.sleep(150);
            t.interrupt();
              
            Thread.sleep(150);
        }
        catch(InterruptedException e){
            System.out.println("Thread has been interrupted");
        }
        System.out.println("Main thread finished...");
    }
}
\end{lstlisting}

Данная программа создаст поток, затем подождёт 150 мс и прервёт его. За это время поток выполнит некоторую часть работы, а затем перехватчик исключений вернёт строку \verb|JThread finished...|. 

При выходе из \verb|try-catch|, тем не менее, поток пробудится, т.е. состояние прерывания вновь станет ложным, поэтому в случае, если это применяется в циклах, используют повторное прерывание потока внутри блока \verb|catch| либо принудительный выход из цикла.

Что же касается жизненного цикла потоков, то он выглядит следующим образом:

\begin{enumerate}
    \item Создание нового потока;
    \item Запуск потока при помощи \verb|start()| и его становление в очередь ожидания выполнения;
    \item Непосредственно выполнение потока, вернее, кода внутри метода \verb|run()|;
    \item Блокировка потока (прерывание, усыпление на некоторое количество времени);
    \item Остановка и уничтожение потока при выполнении всего кода внутри \verb|run()|.
\end{enumerate}

\section{Примитивы управления потоками}

Мы также можем использовать сразу два и более потока — например, для симуляции взаимодействия между ними. Но тогда необходимо каким-либо образом извещать один поток, что второй поток произвёл некоторую работу. Для подобных ситуаций мы можем использовать следующие методы:

\begin{enumerate}
    \item \verb|suspend()| — приостановка потока;
    \item \verb|stop()| — полная остановка потока;
    \item \verb|resume()| — возобновление потока, ранее остановленного с помощью \verb|suspend()|;
    \item \verb|wait()| — текущий поток переводится в режим ожидания;
    \item \verb|notify()| — продолжает работу потока, у которого ранее был вызван метод \verb|wait()|;
    \item \verb|notifyAll()| — продолжает работу всех потоков, у которых ранее был вызван метод \verb|wait()|.
\end{enumerate}

На данный момент первый три метода являются устаревшими, и поэтому рекомендуется использовать \verb|wait()|, \verb|notify()| и \verb|notifyAll()| как обладающие схожем функционалом.

\section{Пулы потоков}

Иногда требуется создавать несколько потоков — но что если это необходимо делать в режиме реального времени, например, в серверном приложении? Ручное добавление потоков в этом случае нецелесообразно — неизвестно, сколько именно потоков необходимо создать, — поэтому для таких случаев используют \textbf{пулы потоков} — группы рабочих потоков, ожидающих выполнения задания.

В пуле потоков создается группа потоков фиксированного размера. Всякий раз, когда задача должна быть предоставлена, один из потоков извлекается и назначается этой задачей поставщиком услуг, как только задание завершается, поток возвращается обратно в пул потоков. Пул потоков предпочтительно используется, потому что активные потоки потребляют системные ресурсы, а когда JVM создает слишком много потоков одновременно, то системе может не хватить памяти.

При работе с пулами могут присутствовать следующие риски:

\begin{enumerate}
    \item Утечка потока — поток удалён из пула, но не возвращён обратно при завершении задачи;
    \item Дедлок (deadlock) — несколько потоков ожидают выполнения друг друга;
    \item Перерасход ресурсов — при слишком большом количестве потоков может произойти нестабильное распределение памяти, ведущее с непредсказуемым последствиям.
\end{enumerate}

Пример работы пула потоков:

\begin{lstlisting}
import java.util.concurrent.LinkedBlockingQueue;
 
public class ThreadPool {
    private final int nThreads;
    private final PoolWorker[] threads;
    private final LinkedBlockingQueue<Runnable> queue;
     
    public ThreadPool(int Threads) {
        this.nThreads = Threads;
        queue = new LinkedBlockingQueue<Runnable>();
        threads = new PoolWorker[Threads];
         
        for (int i = 0; i < nThreads; i++) {
            threads[i] = new PoolWorker();
            threads[i].start();
        }
    }
     
    public void execute(Runnable task) {
        synchronized (queue) {
            queue.add(task);
            queue.notify();
        }
    }
     
    private class PoolWorker extends Thread {
        public void run() {
            Runnable task;
             
            while (true) {
                synchronized (queue) {
                    while (queue.isEmpty()) {
                        try {
                            queue.wait();
                        } catch (InterruptedException e) {
                            System.out.println(e.getMessage());
                        }
                    }
                    task = (Runnable)queue.poll();
                }
         
            // If we don't catch RuntimeException,
            // the pool could leak threads
            try {
                task.run();
            } catch (RuntimeException e) {
                System.out.println(e.getMessage());
            }
            }
        }
    }
}
\end{lstlisting}

\chapter{Синхронизация между потоками}

\section{Проблемы корректной работы многопоточных приложений}

Многопоточные приложения являются полезным и выгодным способом решения задач, например, вычисления выражений или обработки данных, однако это обходится в большое количество потенциальных трудностей — например, если потоки обращаются к одному и тому же ресурсу, то нужно каким-либо образом разграничить их выполнение так, чтобы они не обращались к нему одновременно.

Классическим примером можно считать \textbf{состояние гонки} — ситуацию, когда несколько потоков обращаются к одному и тому же ресурсу, причём один из производит запись в него и при этом порядке обращений заранее не определён. Данная проблема может проявляться в абсолютно случайные моменты и приводить к непредсказуемым последствиям, которые к тому же зависят от аппаратуры, программы, входных данных и т.п. — поэтому состояние гонки можно считать \textbf{«плавающей» ошибкой (гейзенбагом)}.

Рассмотрим пример данного поведения:

\begin{lstlisting}
class Counter{
  int count;
  public void incr(){count++;}
}
public class MyClass {
  public static void main(String[] args)throws InterruptedException {

    Counter c = new Counter();
    Thread t1 = new Thread(new Runnable(){
      public void run(){
        for(int i=0; i<1000; i++)
          c.incr();
      }
    });

    Thread t2 = new Thread(new Runnable(){
      public void run(){
        for(int i=0; i<1000; i++)
          c.incr();
      }
    });

    t1.start();
    t2.start();

    t1.join();
    t2.join();
    
    System.out.println("Count = " + c.count);
  }
}
\end{lstlisting}

Кажется, что потоки будут выполняться строго последовательно: сначала первый поток увеличит переменную \verb|c| 1000 раз, а затем второй поток сделает это 1000 раз, причём эти потоки будут чередоваться. В действительности же произойдёт следующее:

\begin{enumerate}
    \item Первый поток увеличит переменную на 1, как и полагается, НО операция \verb|c++| не атомарна, т.е. она выполняется за несколько тактов процессора;
    \item Между этими тактами второй поток также увеличивает значение потока, причём первое действие теряется безвозвратно;
    \item После выполнения всех потоков выведенное число, в зависимости от перекрытых действий, может выдать число, меньшее 2000, а иногда и ровно 2000.
\end{enumerate}

Одним из решений проблемы считается прерывание потока на время работы другой, но тогда возникает проблема \textbf{дедлока} — два или более потока могут быть заблокированы, при этом они ожидают друг у друга снятия блокировок. Поскольку все они ожидают действий у своих соседствующих потоков, то блокировка продолжается бесконечно либо до искуственного прерывания. Поэтому обычно применяют \textbf{синхронизацию потоков}, которая решает все эти вопросы.

\section{Синхронизация потоков, ключевое слово synchronized}

При выполнении нескольких потоков они будут неизменно взаимодействовать друг с другом, чтобы синхронизировать свое выполнение. В случае выше мы можем добавить ключевое слово \verb|synchronized|, которое является гарантом того, что только один поток будет выполнять данную функцию. При попытке второго метода запустить функцию во время работы первого потока ничего не произойдёт, т.к. этот поток получил сигнал о занятости функции.

Перепишем пример, сделав функцию \verb|incr()| синхронизируземой:

\begin{lstlisting}
class Counter{
  int count;
  public synchronized void incr(){count++;}
}
public class MyClass {
  public static void main(String[] args)throws InterruptedException {

    Counter c = new Counter();
    Thread t1 = new Thread(new Runnable(){
      public void run(){
        for(int i=0; i<1000; i++)
          c.incr();
      }
    });

    Thread t2 = new Thread(new Runnable(){
      public void run(){
        for(int i=0; i<1000; i++)
          c.incr();
      }
    });

    t1.start();
    t2.start();

    t1.join();
    t2.join();
    
    System.out.println("Count = " + c.count);
  }
}
\end{lstlisting}

Теперь на выход всегда будет подаваться строка \verb|"Count = 2000"|, потому что два потока отныне работают \textit{паралелльно друг другу}.

Каждый объект в Java имеет ассоциированный с ним \textbf{монитор}. Монитор представляет своего рода инструмент для управления доступа к объекту. Когда выполнение кода доходит до оператора \verb|synchronized|, монитор объекта \verb|c| блокируется, и на время его блокировки монопольный доступ к блоку кода имеет только один поток, который и произвел блокировку. После окончания работы блока кода, монитор объекта \verb|c| освобождается и становится доступным для других потоков.

После освобождения монитора его захватывает другой поток, а все остальные потоки продолжают ожидать его освобождения.

\section{Стратегии синхронизации}

Для синхронизации потоков используются следующие методики:

\begin{enumerate}
    \item Мониторы;
    \item Ручное взаимодействие между потоками через методы (\verb|wait()|, \verb|notify()|, \verb|notifyAll()|);
    \item Семафоры — специальные счётчики, позволяющие регламентировать количество потоков для одновременного выполнения и их порядок;
    \item Обмен между потоками при помощи класса \verb|Exchanger|;
    \item Объединение схожих потоков в фазы посредством \verb|Phaser|;
    \item Блокировки потоков.
\end{enumerate}

\section{Блокировки потоков}

В качестве альтернативы синхронизации мы можем использовать \textbf{блокировки}. Работают они следующим образом: вначале поток пытается получить доступ к ресурсу. Если он свободен, то на него накладывается блокировка, а поток начинает работу с ним. Остальные же потоки при активной блокировке ожидают снятия блокировки — она производится изначальным потоком при завершении действий с ресурсом.

Классы блокировок реализуют интерфейс \verb|Lock|, который определяет следующие методы:

\begin{enumerate}
    \item \verb|void lock()|: ожидает, пока не будет получена блокировка;
    \item \verb|void lockInterruptibly() throws InterruptedException|: ожидает, пока не будет получена блокировка, если поток не прерван;
    \item \verb|boolean tryLock()|: пытается получить блокировку, если блокировка получена, то возвращает true. Если блокировка не получена, то возвращает false. В отличие от метода \verb|lock()| не ожидает получения блокировки, если она недоступна
    \item \verb|void unlock()|: снимает блокировку
    \item \verb|Condition newCondition()|: возвращает объект \verb|Condition|, который связан с текущей блокировкой
\end{enumerate}

Организация блокировки в общем случае довольно проста: для получения блокировки вызывается метод \verb|lock()|, а после окончания работы с общими ресурсами вызывается метод\verb|unlock()|, который снимает блокировку.

Объект \verb|Condition| позволяет управлять блокировкой.

Как правило, для работы с блокировками используется класс \verb|ReentrantLock|, взятый из пакета 
\verb|java.util.concurrent.locks|. Данный класс реализует интерфейс \verb|Lock|.

\begin{lstlisting}
import java.util.concurrent.locks.ReentrantLock;
 
public class Program {
  
    public static void main(String[] args) {
          
        CommonResource commonResource= new CommonResource();
        ReentrantLock locker = new ReentrantLock();
        for (int i = 1; i < 6; i++){
              
            Thread t = new Thread(new CountThread(commonResource, locker));
            t.setName("Thread "+ i);
            t.start();
        }
    }
}
  
class CommonResource{
      
    int x=0;
}
  
class CountThread implements Runnable{
  
    CommonResource res;
    ReentrantLock locker;
    CountThread(CommonResource res, ReentrantLock lock){
        this.res=res;
        locker = lock;
    }
    public void run(){
         
        locker.lock();
        try{
            res.x=1;
            for (int i = 1; i < 5; i++){
                System.out.printf("%s %d \n", Thread.currentThread().getName(), res.x);
                res.x++;
                Thread.sleep(100);
            }
        }
        catch(InterruptedException e){
            System.out.println(e.getMessage());
        }
        finally{
            locker.unlock();
        }
    }
}
\end{lstlisting}

Здесь также используется общий ресурс \verb|CommonResource|, для управления которым создается пять потоков. На входе в критическую секцию устанавливается заглушка \verb|locker.lock()|. После этого только один поток имеет доступ к критической секции, а остальные потоки ожидают снятия блокировки. В блоке finally после всей окончания основной работы потока эта блокировка снимается. Причем делается это обязательно в блоке finally, так как в случае возникновения ошибки все остальные потоки окажутся заблокированными.

Для применения объектов класса \verb|Condition| используются такие же по функциональности методы, что и для управления потоков:

\begin{enumerate}
    \item \verb|await()|: поток ожидает, пока не будет выполнено некоторое условие и пока другой поток не вызовет методы \verb|signal()/signalAll()|. Во многом аналогичен методу \verb|wait()| класса \verb|Object|;
    \item \verb|signal()|: сигнализирует, что поток, у которого ранее был вызван метод \verb|await()|, может продолжить работу. Применение аналогично использованию методу \verb|notify()| класса \verb|Object|;
    \item \verb|signalAll()|: сигнализирует всем потокам, у которых ранее был вызван метод \verb|await()|, что они могут продолжить работу. Аналогичен методу \verb|notifyAll()| класса \verb|Object|.
\end{enumerate}

\label{pages_total}
