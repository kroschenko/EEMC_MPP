\newpage % Эта команда начинает новую страницу
\chapter{Тема лекции}% Эта команда начинает первую лекцию. В фигурных скобках нужно
% записать тему лекции. Эта тема лекции автоматически получит порядковый номер и
% автоматически добавится в раздел <<Содержание>>. Лекций можно создавать сколько угодно.
% Для создания новой лекции скопируйте и вставьте (или наберите с клавиатуры) команду
% \chapter{Тема лекции} в любую часть рабочего файла. Можете смело менять местами лекции --
% вся нумерация после очередной компиляции поменяется автоматически.

% При необходимости здесь можно разместить любой текст

\section{Название параграфа}% Эта команда начнет раздел, который будем далее условно называть
% параграф. В роли параграфа будет выступать структурная часть лекции (отдельный раздел,
% вопрос и т.п.). В фигурных скобках нужно вписать название параграфа. Параграф автоматически
% получит порядковый номер, который будет состоять из двух чисел, разделенных точкой.
% Первое число -- порядковый номер лекции, второе число -- порядковый номер параграфа в
% пределах лекции. Параграфов можно создавать сколько угодно. Для создания нового параграфа
% скопируйте и вставьте (или наберите с клавиатуры) команду \section{Название параграфа} в
% любую часть рабочего файла. Можете смело менять местами параграфы, переносить их из одной
% лекции  в другую -- вся нумерация после очередной компиляции поменяется автоматически.

% При необходимости здесь можно разместить любой текст

\subsection{Название подпараграфа}% Эта команда начинает подраздел, который далее будем
% условно называть подпараграфом. В фигурных скобках нужно вписать название подпараграфа.
% Подпараграф автоматически получит порядковый номер, который будет состоять из трех
% чисел, разделенных точками. Первое число -- порядковый номер лекции, второе число --
% порядковый номер параграфа, третье число -- порядковый номер подпараграфа. Подпараграфов
% можно создавать сколько угодно. Для создания нового подпараграфа скопируйте и вставьте
% (или наберите с клавиатуры) команду \subsection{Название подпараграфа} в любую часть
% Рабочего файла. Можете смело менять подпараграфы местами, переносить их из одного
% параграфа в другой (даже другой параграф другой лекции) -- вся нумерация после очередной
% компиляции поменяется автоматически.

Теперь можно приступать к формированию первой лекции Вашего учебно-методического
комплекса. Внимательно прочитайте все рекомендации <<Руководства пользователю>>.

Несколько важных моментов из <<Руководства пользователю>> мы продублируем и здесь.

Начнем с самого главного -- примера оформления программного кода в \LaTeX:

\begin{lstlisting}
    //example of simple java-program
    public class HelloWorld
    {
        public static void main(String[] args)
        {
            int i = 12;
            int a = i + 100;
            System.out.println("Hello, world!");
        }
    }
\end{lstlisting}

Определенные части текста (не содержащие формул, таблиц и иллюстраций -- о них речь пойдет
ниже) могут быть скопированы и вставлены  в рабочий документ из любого
другого текстового редактора. Исходный текст документа не должен содержать переносов
(\LaTeX~ создат их сам). Слова должны отделяться
друг от друга пробелами, но при этом \LaTeX у все-равно, сколько именно пробелов Вы
оставили между
словами, все пробелы \LaTeX~воспримет как один пробел
 (чтобы вручную управлять пробелами между словами можно использовать символ
$\sim$, который называют неразрывным пробелом).
 Конец строки также воспринимается как пробел.
Отдельные абзацы должны быть отделены друг от друга пустыми строками (опять-таки все равно,
сколько именно пустых строк стоит между абзацами, важно, чтобы была хоть одна).

Приведем пример создания определения:

\begin{opr}\label{oprperv} \rm Первообразной функции $f$ на множестве $X{\subset}D(f)$
называется такая функция $F,$ определённая на $X,$ что для любой
точки $x\in{X}$ будет выполняться равенство
  $$F'(x)=f(x).$$
\end{opr}

Пример создания теоремы:
\begin{theorem}\label{theorperv} Если функция $F$ является первообразной для функции $f$
на промежутке $X,$ то:

   {\rm a)} $F(x)+C$ также является первообразной для функции $f$ на промежутке
$X,$ где $C$ --- произвольная действительная постоянная;

    {\rm б)} для любой
другой первообразной $\Phi(x)$ функции $f$ на промежутке $X$
существует такая действительная константа $C,$ что
  $$\Phi(x)=F(x)+C.$$
\end{theorem}

Приведем пример создания гиперссылок на определение \ref{oprperv}  и теорему \ref{theorperv}.

Чтобы научиться легко создавать любые гиперссылки, внимательно прочитайте <<Руководство
пользователю>>.

Теперь приведем пример создания метки {\color{green}\hypertarget{metkatext}{на часть текста}}.

Теперь создадим гиперссылку на словосочетание <<часть текста>>. Пусть эта гиперссылка
состоит из слов <<\hyperlink{metkatext}{текстовая гиперссылка}>>

Пример создания списка:
\begin{enumerate}
\item текст;
\item текст;
\item текст.
\end{enumerate}

Пример создания следствия:
\begin{corollary}{\rm(Свойство линейности)}. Если на промежутке $I$ существуют $\int
f_k(x)dx, k=\overline{1,n}$, а $\alpha_k$ --- произвольные
действительные константы, причем хотя бы одна из них отлична от
нуля, то на $I$ существует $$\int\left(\sum_{k=1}^n \alpha_k
f_k(x)\right)dx=\sum_{k=1}^n \alpha_k
\int{f_k(x)dx}.$$\end{corollary}

Пример вставки рисунка 1n.png из папки <<pic>>/<<images>>.
\begin{figure}[h!]\center
  \includegraphics[height=5.11cm,bb=0 0 464 766]{1n.jpg}
   \caption{Тело вращения}\label{ris1}
\end{figure}

Пример вставки гиперссылки на запуск звукового файла 2.wma из папки <<media>>:
Послушаем \href{run:media/2.wma}{музыку}?

Пример вставки гиперссылки на запуск видео файла film.wmv из папки <<media>>:
\href{run:media/film.avi}{видеофильм}?

\section{Справочная информация}

Этот параграф можно назвать как угодно. Мы установим на первую страницу этого параграфа
метку \label{mybutton}, которая является <<мишенью>> Вашей кнопки на интерактивной панели
(описание процесса ее создания смотрите выше в комментариях).
\begin{enumerate}% Эта команда начинает список
\item Важная информация.
\item Очень важная информация.
\end{enumerate}% Эта команда завершает список

Если теперь скомпилировать <<Рабочий файл>>, то запустив электронный
учебник (файл UMK.pdf) и нажав на кнопку <<Ваша кнопка>> на интерактивной
панели, Вы попадете на эту страницу.

%--------------------------------------------------------------------------------------------

\section*{Вопросы и задания для самоконтроля}% Этот раздел будет состоять из вопросов
% и заданий для самоконтроля.
\addcontentsline{toc}{struct}{Вопросы и задания для самоконтроля}% Эта команда
% добавляет название раздела в раздел <<Содержание>>

Здесь можете привести список вопросов и заданий для самоконтроля:
\begin{enumerate}% Эта команда начинает список
\item Вопрос или задание.
\item Вопрос или задание.
\item Вопрос или задание.
\item Вопрос или задание.
\end{enumerate}% Эта команда завершает список

А можете подготовить с помощью программы IrenEditor (см. <<Руководство пользователю>>)
тестовое задание для самоконтроля, сохранить его в папку
<<test>>, назвав, например, lk1.exe, и создать на него метку с помощью
команды (см. <<Руководство пользователю>>): \href{run:test/lk1.exe}{Пройдем тестирование?}



%---------------------------------------------------------------------------------------------
\newpage% Эта команда задает разрыв страницы (начинает новую страницу).
\section*{ПРАКТИЧЕСКОЕ ЗАНЯТИЕ 1}% Эта команда начинает первое практическое занятие.
% Обратите внимание -- практические занятия придется нумеровать вручную.
\addcontentsline{toc}{chapter}{Практическое занятие 1 {\bf Тема занятия}} \vspace{-10pt}% Эти
% команды добавляют тему занятия в раздел <<Содержание>>
\begin{center}% Эта команда выравнивает текст по центру строки.
 {\bf% Эта команда делает шрифт полужирным
 Тема занятия}
\end{center}% Эта команда завершает <<центрирование>> текста.

{\bf Цель:} Сюда можно вписать цель практического занятия.
\\% Эта команда вставляет пустую строку.

Ваш текст.

%--------------------------------------------------------------------------------------------
\newpage% Эта команда начинает новую страницу
\section*{Задания для самостоятельного решения (выполнения)}% Эта команда начинает раздел с
% заданиями для самостоятельной работы
\addcontentsline{toc}{struct}{Задания для самостоятельного решения}% Эта команда добавляет
% название раздела в раздел <<Содержание>>

Ваш текст

\newpage% Эта команда задает новую страницу (разрыв страницы)

%--------------------------------------------------------------------------------------------

\newpage % Эта команда начинает новую страницу
\chapter{Система типов. Методы, общие для всех классов}

\section{Система типов Java}

В Java система типов является статической, строгой и безопасной системой типизации. Вот несколько основных аспектов, которые стоит знать о системе типов в Java:
\begin{itemize}
    \item Типы данных: Java имеет встроенные примитивные типы данных, такие как int, float, boolean и другие, а также ссылочные типы данных, такие как классы, интерфейсы и массивы.

    \item Статическая типизация: В Java типы данных должны быть объявлены явно, и компилятор проверяет соответствие типов на этапе компиляции. Это означает, что ошибки типизации обнаруживаются на этапе компиляции, а не во время выполнения программы.

    \item Наследование и полиморфизм: Java поддерживает наследование классов и интерфейсов, что позволяет создавать иерархию классов с общим поведением. Полиморфизм позволяет использовать объекты разных классов, реализующих один и тот же интерфейс, взаимозаменяемо.

    \item Обработка исключений: Java использует систему обработки исключений, которая позволяет контролировать и обрабатывать ошибки, возникающие во время выполнения программы. Исключения в Java также являются типами данных, определенными в системе типов.

    \item Дженерики: Java поддерживает дженерики, что позволяет создавать обобщенные типы данных и методы, параметризованные типами. Это позволяет создавать более безопасные и типобезопасные коллекции и алгоритмы.

    \item Аннотации: Java также поддерживает использование аннотаций, которые позволяют аннотировать классы, методы, поля и другие элементы кода метаданными. Аннотации могут быть использованы для статической проверки кода, генерации кода, документирования и других целей.
\end{itemize}
Система типов в Java является одним из основных инструментов для обеспечения безопасности и надежности Java-программ, и она играет важную роль в статической проверке и контроле типов во время компиляции программы.
\section{Методы, общие для всех объектов: hashCode, equals, toString, clone, compareTo, finalize}
\subsection{hashCode}
hashCode в Java - это метод, определенный в классе Object, который возвращает целочисленное значение (32-битное целое число), представляющее "хэш-код" объекта. Хэш-код используется в структурах данных, таких как хэш-таблицы, для оптимизации поиска, сравнения и доступа к объектам.
Использование правильной реализации hashCode в сочетании с правильной реализацией equals() может помочь в правильном функционировании коллекций, таких как HashMap, HashSet и других, которые используют хэш-коды для эффективного поиска и сравнения объектов в Java.
Пример:
\begin{lstlisting}
    public class Person {
    private String firstName;
    private String lastName;
    private int age;

    public Person(String firstName, String lastName, int age) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
    }
    Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Person)) return false;
        Person person = (Person) o;
        return age == person.age \&\&
            Objects.equals(firstName, person.firstName) \&\&
                Objects.equals(lastName, person.lastName);
    }
    Override
    public int hashCode() {
        return Objects.hash(firstName, lastName, age);
    }
}
\end{lstlisting}
В этом примере метод equals сравнивает все поля объектов Person на равенство, включая firstName, lastName и age. Метод hashCode использует метод Objects.hash(), который генерирует хэш-код на основе значений полей firstName, lastName и age.
\subsection{equals} 
Метод equals в Java используется для сравнения двух объектов на равенство.
Метод equals должен быть переопределен в классе, если вы хотите сравнивать объекты этого класса на основе их содержимого, а не ссылок на объекты. По умолчанию, метод equals в классе наследуется от класса Object и выполняет сравнение по ссылке, то есть возвращает true только в случае, если сравниваемые объекты являются одной и той же ссылкой на объект в памяти.

При переопределении метода equals важно соблюдать следующие рекомендации:
\begin{itemize}
    \item Рефлексивность: объект должен быть равен самому себе, то есть x.equals(x) должен возвращать true.
    \item Симметричность: если x.equals(y) возвращает true, то и y.equals(x) должен возвращать true.
    \item Транзитивность: если x.equals(y) возвращает true, и y.equals(z) возвращает true, то и x.equals(z) должен возвращать true.
    \item Консистентность: повторные вызовы x.equals(y) должны всегда возвращать одинаковый результат, если объекты не изменяются.
    \item Сравнение с null: x.equals(null) должен возвращать false.
\end{itemize}
Вот пример реализации метода equals в классе Person:

\begin{lstlisting}
     Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (!(o instanceof Person)) return false;
    Person person = (Person) o;
    return age == person.age &&
            Objects.equals(firstName, person.firstName) &&
            Objects.equals(lastName, person.lastName);
}
\end{lstlisting}
В этом примере метод equals сравнивает все поля объектов Person на равенство, включая firstName, lastName и age. Метод Objects.equals() используется для безопасного сравнения объектов, включая возможность обработки null значений.
\subsection{toString}
toString() - это метод в Java, который принадлежит классу Object и используется для представления объекта в виде строки. Метод toString() возвращает строковое представление объекта, которое может быть использовано для отображения информации о состоянии объекта или его содержимом.
Пример:
\begin{lstlisting}
    public class Person {
    private String name;
    private int age;
    
    Override
    public String toString() {
        return "Person [name=" + name + ", age=" + age + "]";
    }
}
\end{lstlisting}
В этом примере метод toString() возвращает строку, содержащую имя и возраст объекта класса Person, что может быть полезно для отображения информации о человеке в виде строки.
\subsection{clone}
clone() - это метод в Java, который позволяет создать копию объекта. Метод clone() определен в интерфейсе Cloneable, и его использование предполагает, что класс объекта, для которого вызывается этот метод, поддерживает клонирование и реализует этот интерфейс.
Пример:
\begin{lstlisting}
    public class Person implements Cloneable {
    private String name;
    private int age;

    Override
    public Person clone() {
        try {
            return (Person) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
            return null;
        }
    }
}
\end{lstlisting}
\subsection{compareTo}
compareTo() - это метод в Java, который позволяет сравнивать объекты на основе их естественного порядка. Метод compareTo() определен в интерфейсе Comparable, и его использование предполагает, что класс объекта, для которого вызывается этот метод, реализует этот интерфейс.
Пример:
\begin{lstlisting}
    public class Person implements Comparable<Person> {
    private String name;
    private int age;

    Override
    public int compareTo(Person other) {
        return Integer.compare(this.age, other.age);
    }
}
\end{lstlisting}
В данном примере метод compareTo() сравнивает объекты класса Person на основе их возраста, что позволяет упорядочить объекты по возрасту при использовании сортировки в коллекциях или алгоритмах сортировки.
\subsection{finalize}\
finalize() - это метод в Java, который вызывается перед тем, как объект будет удален сборщиком мусора. Метод finalize() определен в классе Object, и каждый объект в Java наследует этот метод.
Пример:
\begin{lstlisting}
    public class MyResource {
    Override
    protected void finalize() throws Throwable {
        try {
        } finally {
            super.finalize();
        }
    }
}
\end{lstlisting}
В данном примере метод finalize() переопределен для освобождения ресурсов, представленных объектом класса MyClass, перед его удалением из памяти. Однако, такой подход не рекомендуется, и более предпочтительным будет использование других механизмов, таких как try-with-resources, для явного освобождения ресурсов.
\section{Тривиальная реализация equals и необходимость её переопределения}
Тривиальная реализация equals() в Java сравнивает объекты по их ссылкам в памяти, что эквивалентно оператору ==. Однако, эта реализация может не соответствовать ожидаемому поведению для сравнения объектов на равенство в контексте содержимого объектов. В таких случаях может потребоваться переопределение equals() для определения собственной логики сравнения объектов на основе их содержимого.

Необходимость переопределения equals() может возникнуть в следующих ситуациях:
\begin{enumerate}
    \item Сравнение содержимого объектов: Если объекты имеют состояние или поля, важные для равенства объектов, то тривиальная реализация equals(), сравнивающая только ссылки на объекты, может давать неправильные результаты. В таких случаях переопределение equals() позволяет сравнивать содержимое объектов, например, значения полей.

    \item Определение правил равенства: Если требуется определить собственные правила равенства объектов в контексте бизнес-логики приложения, то тривиальная реализация equals() может быть недостаточной. В таких случаях переопределение equals() позволяет определить собственные правила сравнения объектов.

    \item Использование в коллекциях: Если объекты предполагается использовать в коллекциях, таких как HashMap, HashSet и других, где требуется правильное функционирование операций поиска, удаления и вставки, то тривиальная реализация equals() может привести к непредсказуемому поведению коллекций. В таких случаях рекомендуется переопределение equals() и hashCode() в соответствии с требованиями коллекций.
\end{enumerate}
Пример переопределения метода equals() в Java:
\begin{lstlisting}
   public class MyClass {
    private int id;
    private String name;

    Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof MyClass)) return false;
        MyClass other = (MyClass) o;
        return this.id == other.id && Objects.equals(this.name, other.name);
    }
}
\end{lstlisting}

\newpage
\chapter{Обобщенные типы данных. Ограничения обобщенных типов}
\section{Концепция обобщенного программирования}
Концепция обобщенного программирования (Generic programming) - это подход к разработке программного обеспечения, который позволяет создавать абстрактные типы данных и алгоритмы, которые могут работать с различными типами данных.

В традиционном программировании, если вы хотите написать функцию для сортировки массива, вы должны были бы написать отдельный код для каждого типа элемента массива, например, для сортировки целых чисел и сортировки строк.

В обобщенном программировании вы можете написать универсальную функцию для сортировки, которая может работать с различными типами данных, такими как целые числа, строки, объекты пользовательских классов и т.д., используя параметры типа (Type parameters). Таким образом, вы можете повторно использовать код и избежать дублирования.

Параметры типа позволяют определить классы, интерфейсы, методы или другие конструкции, которые работают с абстрактными типами данных, вместо конкретных типов. В Java, например, параметры типа указываются в угловых скобках и могут быть использованы для создания обобщенных классов, интерфейсов и методов.
Пример:
\begin{lstlisting}
    public class Box<T> {
    private T content;

    public void put(T item) {
        this.content = item;
    }

    public T get() {
        return content;
    }

    public static <T> void print(T[] arr) {
        for (T item : arr) {
            System.out.println(item);
        }
    }
}
\end{lstlisting}
Класс Box - это обобщенный класс, который может хранить объекты любого типа, передаваемого через параметр типа T. Метод put() сохраняет переданный ему объект внутри объекта Box, а метод get() возвращает сохраненный объект.

Метод print() - это статический обобщенный метод, который может выводить на экран элементы массива любого типа, передаваемого через параметр типа T.

\section{Безопасность типов,Generic-методы}
Безопасность типов - это свойство языка программирования, которое обеспечивает контроль типов данных и проверку их корректности во время компиляции, а не во время выполнения программы. Это позволяет выявлять ошибки типов и предотвращать их возникновение на этапе компиляции, что уменьшает количество ошибок во время выполнения программы и повышает ее надежность.

Обобщенные методы - это методы, которые позволяют определять параметры типа внутри метода, вместо того чтобы определять их на уровне класса. Обобщенные методы часто используются вместе с обобщенными классами, чтобы предоставить дополнительные возможности для работы с различными типами данных.

Использование обобщенных методов может улучшить безопасность типов, поскольку это позволяет контролировать типы данных, передаваемые в метод, и гарантировать, что они корректны. Обобщенные методы могут принимать параметры типа и возвращать значения с типами, которые определены во время компиляции, что обеспечивает безопасность типов во время выполнения программы.
Пример:
\begin{lstlisting}
    public class Utils {
    public static <T> T first(List<T> list) {
        if (list.isEmpty()) {
            return null;
        } else {
            return list.get(0);
        }
    }
}
\end{lstlisting}
В этом примере метод first() - это обобщенный метод, который принимает список объектов любого типа, передаваемого через параметр типа T. Метод возвращает первый элемент списка, если список не пустой, или null, если список пустой.

Этот метод обеспечивает безопасность типов, поскольку он гарантирует, что тип возвращаемого значения соответствует типу объектов в списке, передаваемом в качестве аргумента. Если бы метод first() не был обобщенным, он мог бы возвращать Object, что могло бы привести к ошибкам типов во время выполнения программы.

\section{Шаблоны аргументов, ограничения параметров типов}
Шаблоны аргументов (англ. type parameterization, type templating) - это механизм языка программирования, который позволяет создавать обобщенные классы и методы, которые могут работать с различными типами данных. Параметры типов используются для определения типа данных, с которым работает класс или метод, и могут быть использованы для создания экземпляров классов, вызова методов, передачи аргументов и возвращения значений.

Ограничения параметров типов (англ. type parameter constraints) - это дополнительные правила, которые могут быть применены к параметрам типов в обобщенных классах и методах. Ограничения параметров типов позволяют определять, какие типы данных могут быть использованы в качестве параметров типов, и могут быть использованы для проверки правильности типов данных во время компиляции.

Ограничения параметров типов могут быть заданы в виде интерфейсов, которые тип параметра должен реализовать, или в виде классов, от которых тип параметра должен наследоваться. Ограничения параметров типов могут быть определены с помощью ключевого слова extends.
Пример:
\begin{lstlisting}public class Example<T extends Number> {
    private T data;

    public Example(T data) {
        this.data = data;
    }

    public T getData() {
        return data;
    }

    public static <T extends Comparable<T>> T max(T a, T b) {
        if (a.compareTo(b) > 0) {
            return a;
        } else {
            return b;
        }
    }
}
    public class Example<T extends Number> {
    private T data;

    public Example(T data) {
        this.data = data;
    }

    public T getData() {
        return data;
    }

    public static <T extends Comparable<T>> T max(T a, T b) {
        if (a.compareTo(b) > 0) {
            return a;
        } else {
            return b;
        }
    }
}
\end{lstlisting}
В этом примере класс Example является обобщенным и принимает параметр типа T, который должен быть наследником класса Number. Класс имеет одно поле данных data типа T и метод getData(), который возвращает значение поля data.

Также в этом примере определен статический обобщенный метод max(), который принимает два аргумента типа T, ограниченные интерфейсом Comparable. Метод сравнивает два объекта и возвращает максимальный из них.

\section{"Стирание" типов}
"Стирание типов" (англ. type erasure) - это процесс компиляции обобщенного кода в байт-код Java, в котором информация о типах параметров обобщенных классов и методов удаляется (стирается) и заменяется на Object. Это делается для обеспечения совместимости обобщенного кода с версиями Java, выпущенными до появления обобщений в Java 5.

Поскольку Java является языком с жесткой типизацией, компилятору необходимо знать типы данных для проверки типов во время компиляции и выполнения. Поэтому информация о типах параметров сохраняется только на этапе компиляции, а во время выполнения байт-код использует стертый тип. Поскольку в байт-коде нет информации о типах параметров, компилятор не может проверить типы данных во время выполнения.

При компиляции обобщенных классов и методов компилятор Java создает "bridge-методы" (мостовые методы), которые позволяют работать с обобщенным кодом в рантайме, используя только стертые типы. Эти мостовые методы гарантируют, что обобщенный код может работать с различными типами данных, сохраняя при этом безопасность типов.
Пример:
\begin{lstlisting}
    public class Example<T> {
    private T data;

    public Example(T data) {
        this.data = data;
    }

    public T getData() {
        return data;
    }
}
\end{lstlisting}
"Стирание типов" (англ. type erasure) - это процесс компиляции обобщенного кода в байт-код Java, в котором информация о типах параметров обобщенных классов и методов удаляется (стирается) и заменяется на Object. Это делается для обеспечения совместимости обобщенного кода с версиями Java, выпущенными до появления обобщений в Java 5.

Поскольку Java является языком с жесткой типизацией, компилятору необходимо знать типы данных для проверки типов во время компиляции и выполнения. Поэтому информация о типах параметров сохраняется только на этапе компиляции, а во время выполнения байт-код использует стертый тип. Поскольку в байт-коде нет информации о типах параметров, компилятор не может проверить типы данных во время выполнения.

При компиляции обобщенных классов и методов компилятор Java создает "bridge-методы" (мостовые методы), которые позволяют работать с обобщенным кодом в рантайме, используя только стертые типы. Эти мостовые методы гарантируют, что обобщенный код может работать с различными типами данных, сохраняя при этом безопасность типов.

Пример использования "стирания типов" на Java:

java

public class Example<T> {
    private T data;

    public Example(T data) {
        this.data = data;
    }

    public T getData() {
        return data;
    }
}

В этом примере класс Example является обобщенным и принимает параметр типа T. Код компилируется в байт-код, в котором тип параметра T стирается и заменяется на Object. В байт-коде создается метод getData(), который возвращает объект типа Object, а не тип T.

\section{Ограничения, накладываемые на использование обобщенных типов Java}
В Java есть несколько ограничений, которые могут быть наложены на использование обобщенных типов:

    Ограничения сверху (upper bounds) - позволяют ограничить тип параметра сверху, то есть указать, что параметр должен быть наследником определенного класса или реализовывать определенный интерфейс. Например:
    \begin{lstlisting}
        public class Example<T extends Number> {
    private T data;

    public Example(T data) {
        this.data = data;
    }

    public T getData() {
        return data;
    }
}
    \end{lstlisting}
В этом примере тип параметра T ограничен сверху классом Number, что означает, что параметр T должен быть наследником класса Number. Это ограничение позволяет использовать методы класса Number, такие как intValue(), doubleValue() и т.д., на параметре T.

    Ограничения снизу (lower bounds) - позволяют ограничить тип параметра снизу, то есть указать, что параметр должен быть предком определенного класса или интерфейса. Например:
    \begin{lstlisting}
        T obj = new T();
    \end{lstlisting}
Это происходит потому, что на этапе выполнения информация о типе T стирается, и компилятор не может создать объект типа T. Вместо этого необходимо использовать фабричные методы или передавать объекты типа T через параметры.

    Нельзя создавать массивы обобщенных типов. Например, следующий код не будет компилироваться:
    \begin{lstlisting}
        T[] array = new T[10];
    \end{lstlisting}
    Это происходит по тем же причинам, что и в предыдущем примере - на этапе выполнения информация о типе T стирается. Вместо этого можно создать массив типа Object и привести его к типу 'T'

\newpage
\chapter{Основные типы коллекций. Свойства коллекций}
\section{Агрегированные данные}
Агрегированные данные в программировании представляют собой коллекции объектов, которые объединены по определенному критерию, например, по типу, свойствам или функциональности. Такие коллекции могут быть использованы для удобного доступа и обработки данных.

В Java агрегированные данные можно представить в виде массивов, коллекций или других структур данных. Например, можно создать класс, представляющий коллекцию объектов и имеющий методы для добавления, удаления и обработки этих объектов:
\begin{lstlisting}
    public class ObjectCollection {
    private List<Object> objects;

    public ObjectCollection() {
        this.objects = new ArrayList<>();
    }

    public void add(Object object) {
        objects.add(object);
    }

    public void remove(Object object) {
        objects.remove(object);
    }

    public void clear() {
        objects.clear();
    }

    public void process(Processor processor) {
        for (Object object : objects) {
            processor.process(object);
        }
    }
}
\end{lstlisting}
В этом примере ObjectCollection представляет собой коллекцию объектов типа Object, которая может быть динамически изменена путем добавления или удаления объектов. Кроме того, у ObjectCollection есть метод process, который принимает объект типа Processor и выполняет над каждым объектом в коллекции некоторую обработку, которую реализует переданный Processor.

Таким образом, агрегированные данные позволяют удобно хранить, обрабатывать и использовать коллекции объектов в программе. Они могут быть полезны во многих задачах, например, в обработке данных, поиске и фильтрации объектов, визуализации информации и т.д.
\section{Интерфейс java.util.Collection}
Интерфейс java.util.Collection в Java представляет общую коллекцию объектов, которая может содержать дубликаты и упорядочена или неупорядочена в зависимости от конкретной реализации. Он определяет базовые операции, которые должны быть реализованы всеми классами-коллекциями в Java, такие как добавление, удаление, поиск элементов и т.д.

Вот несколько основных методов, определенных в интерфейсе \newline
Collection:
    \begin{itemize}
    \item boolean add(E element) - добавляет элемент в коллекцию
    \item boolean remove(Object object) - удаляет объект из коллекции
    \item boolean contains(Object object) - проверяет, содержит ли коллекция объект
    \item int size() - возвращает количество элементов в коллекции
    \item void clear() - удаляет все элементы из коллекции
    \item boolean isEmpty() - проверяет, пуста ли коллекция
    \end{itemize}
\section{Свойства коллекций, определяющие их поведение и дизайн: изменяемые, неизменяемые, персистетные, упорядоченные и т.д.}
Коллекции в Java имеют различные свойства, которые определяют их поведение и дизайн. Некоторые из этих свойств включают:
    \begin{itemize}
   \item Изменяемость: изменяемые коллекции позволяют изменять содержимое коллекции, например, добавлять, удалять или изменять элементы. Неизменяемые коллекции не позволяют изменять содержимое коллекции после ее создания.

    \item Персистентность: персистентные коллекции сохраняют свое содержимое между запусками программы, например, в файле или базе данных. Неперсистентные коллекции не сохраняют свое содержимое между запусками программы.

    \item Упорядоченность: некоторые коллекции могут хранить элементы в определенном порядке, например, по порядку добавления или сортировке. Другие коллекции не имеют определенного порядка.

    \item Доступ к элементам: некоторые коллекции позволяют получать доступ к элементам по индексу, а другие не позволяют это делать.

    \item Дубликаты: некоторые коллекции могут содержать дубликаты элементов, а другие не могут.

    \item Потокобезопасность: некоторые коллекции являются потокобезопасными, что означает, что они могут использоваться в многопоточных приложениях без необходимости в синхронизации. Другие коллекции не являются потокобезопасными и требуют синхронизации при использовании в многопоточных приложениях.
    \end{itemize}
Выбор подходящей коллекции для конкретной задачи зависит от требований к ее свойствам и поведению.
\section{Обзор Java Collections Framework}
Java Collections Framework - это набор классов и интерфейсов, предоставляющий универсальный и эффективный способ работы с коллекциями объектов в Java. Он включает в себя классы для хранения, обработки и манипулирования коллекциями объектов, таких как списки, множества, карты и другие.

Java Collections Framework предоставляет общие интерфейсы, которые определяют базовые методы и свойства коллекций, а также конкретные реализации коллекций, которые предоставляют определенные реализации этих методов и свойств. Все коллекции в Java Collections Framework являются объектами типа java.util.Collection или java.util.Map.

Некоторые из основных интерфейсов, предоставляемых Java \newline Collections Framework, включают:

    Collection: базовый интерфейс для всех коллекций, предоставляет методы для добавления, удаления и получения элементов из коллекции.
    List: интерфейс для упорядоченных коллекций, которые могут содержать дубликаты элементов.
    Set: интерфейс для неупорядоченных коллекций, которые не могут содержать дубликаты элементов.
    Map: интерфейс для коллекций, которые хранят ключи и значения в виде пар.
    Queue: интерфейс для коллекций, которые используются для хранения элементов в порядке, установленном по определенным правилам.

Классы, реализующие эти интерфейсы, могут быть различными в зависимости от требований проекта, например: ArrayList, LinkedList, HashSet, TreeSet, HashMap, TreeMap и др.

\section{Принципы дизайна библиотеки}
Java Collections Framework разработана на основе нескольких принципов дизайна, которые делают ее удобной и эффективной для работы с коллекциями объектов:
    \begin{enumerate}
    \item Интерфейсно-ориентированный дизайн: Java Collections Framework предоставляет общие интерфейсы для коллекций, которые определяют базовые методы и свойства коллекций. Это позволяет программистам использовать одинаковый синтаксис для работы с различными типами коллекций и упрощает реализацию своих собственных коллекций.

    \item Разделение интерфейсов и реализаций: Java Collections Framework разделяет интерфейсы, определяющие базовые методы коллекций, и классы, реализующие эти методы. Это позволяет разработчикам выбирать определенную реализацию коллекции в зависимости от конкретных требований проекта.

    \item Универсальность и гибкость: Java Collections Framework предоставляет реализации различных типов коллекций, включая списки, множества, карты и другие. Каждая реализация имеет свои преимущества и недостатки, что позволяет выбирать определенную реализацию в зависимости от задачи.

    \item Поддержка генериков: Java Collections Framework использует обобщения для обеспечения безопасности типов. Это позволяет программистам указывать типы элементов, которые могут быть добавлены в коллекцию, и обеспечивает проверку типов во время компиляции.

    \item Высокая производительность: Java Collections Framework была разработана с учетом производительности. Он использует эффективные алгоритмы и структуры данных для обеспечения быстрого доступа к элементам коллекции и выполнения других операций.

    \item Итераторы: Java Collections Framework предоставляет итераторы для перебора элементов коллекций. Итераторы обеспечивают безопасность типов и позволяют работать с коллекцией, не зная ее внутреннего устройства.
    \end{enumerate}
\section{Основные интерфейсы и их категории}
Java Collections Framework (JCF) включает несколько основных интерфейсов, которые определяют базовую функциональность коллекций. Они могут быть разделены на три категории:

    Интерфейсы коллекций (Collection Interfaces):
    \begin{itemize}
    \item java.util.Collection
    \item java.util.List
    \item java.util.Set
    \item java.util.Queue
    \item java.util.Deque
\end{itemize}
    Интерфейсы карт (Map Interfaces):
\begin{itemize}
    \item java.util.Map
    \item java.util.SortedMap
    \item java.util.NavigableMap
\end{itemize}
    Дополнительные интерфейсы (Additional Interfaces):
\begin{itemize}
    \item java.util.Iterator
    \item java.util.ListIterator
    \item java.util.Comparator
\end{itemize}
Интерфейсы коллекций определяют базовые операции для работы с коллекциями объектов. Они могут содержать дубликаты элементов (List), не содержать дубликаты (Set), управлять элементами в очереди (Queue) и работать с двусторонними очередями (Deque).

Интерфейсы карт определяют отображение ключей на значения. Они могут сортировать элементы по ключу (SortedMap) и предоставлять дополнительные методы для навигации по элементам (NavigableMap).

Дополнительные интерфейсы используются для навигации по коллекциям (Iterator, ListIterator) и для определения пользовательской логики сравнения объектов (Comparator).

\section{Списки, множества, очереди}
Списки, множества и очереди - это три основных типа коллекций, предоставляемых в Java Collections Framework.

Список (List) - это коллекция, которая содержит упорядоченный набор элементов и позволяет работать с ними по индексу. В Java предоставляется несколько реализаций интерфейса List, таких как ArrayList, LinkedList и Vector.

Множество (Set) - это коллекция, которая не содержит дубликатов элементов. В Java предоставляется несколько реализаций интерфейса Set, таких как HashSet, TreeSet и \newline LinkedHashSet.

Очередь (Queue) - это коллекция, которая работает по принципу "первый пришел - первый обслужен" (FIFO - First-In-First-Out). В Java предоставляется несколько реализаций интерфейса Queue, таких как \newline LinkedList, PriorityQueue и ArrayDeque.

Кроме того, в Java Collections Framework есть несколько других типов коллекций, таких как Map, Deque и SortedSet. Каждый тип коллекции имеет свои особенности и используется в различных ситуациях в зависимости от требований к производительности, доступности элементов и т.д.

\section{Карты и словари в Java}
В Java Collections Framework карты и словари реализуются с помощью интерфейса Map. Map представляет собой коллекцию пар "ключ-значение", где каждый ключ связан с определенным значением.

Некоторые из наиболее часто используемых реализаций Map включают в себя HashMap, TreeMap и LinkedHashMap. Вот краткий обзор каждого из них:

    HashMap - это самая быстрая реализация Map, которая использует хэш-таблицу для хранения элементов. Она обеспечивает постоянное время выполнения для основных операций, таких как добавление, удаление и поиск элементов.

    TreeMap - это реализация Map, которая использует древовидную структуру для хранения элементов. Она обеспечивает сортировку элементов по их ключам и позволяет быстро выполнять операции поиска, удаления и добавления элементов.

    LinkedHashMap - это реализация Map, которая объединяет свойства HashMap и TreeMap, т.е. использует хэш-таблицу для быстрого доступа к элементам и связанный список для поддержания порядка элементов.

Карты и словари широко используются в Java для хранения и поиска данных, таких как пароли, конфигурационные параметры и другие типы ассоциативных массивов. Они также полезны для решения многих задач, связанных с анализом данных и обработкой информации.

\newpage
\chapter{Списки}
\section{Списки в Java}
писки в Java представлены интерфейсом java.util.List. Он наследуется от интерфейса java.util.Collection и расширяет его, добавляя методы для работы со списками.

Список в Java представляет собой упорядоченную коллекцию элементов, в которой каждый элемент может быть получен по индексу. В списке допускаются повторяющиеся элементы, и элементы могут быть вставлены, заменены или удалены из любой позиции в списке.

Реализации списка включают ArrayList, LinkedList, \newline CopyOnWriteArrayList и другие. ArrayList - это список, основанный на массиве, который обеспечивает быстрый доступ к элементам по индексу, но может иметь дополнительные накладные расходы при вставке или удалении элементов. LinkedList - это список, реализованный в виде связного списка, который обеспечивает быструю вставку или удаление элементов, но может иметь некоторые недостатки в производительности при доступе к элементам по индексу.

Классы, реализующие интерфейс List, также могут иметь специфические свойства, такие как возможность дополнения или удаления элементов, ограничения на тип элементов или возможность работы с индексами.

\section{Анализ интерфейса List}
Интерфейс java.util.List определяет функциональность упорядоченной коллекции элементов, в которой каждый элемент может быть доступен по индексу. Он наследуется от интерфейса java.util.Collection и расширяет его, добавляя методы для работы со списками.

Некоторые методы, определенные в интерфейсе List:

    add(E element): добавляет элемент в конец списка.
    add(int index, E element): добавляет элемент в указанную позицию списка.
    remove(Object obj): удаляет первое вхождение указанного элемента из списка.
    remove(int index): удаляет элемент по указанному индексу.
    get(int index): возвращает элемент по указанному индексу.
    set(int index, E element): заменяет элемент в указанной позиции заданным элементом.
    indexOf(Object obj): возвращает индекс первого вхождения указанного элемента в список.
    lastIndexOf(Object obj): возвращает индекс последнего вхождения указанного элемента в список.
    subList(int fromIndex, int toIndex): возвращает список, содержащий элементы с fromIndex до toIndex (не включая toIndex).

Каждый класс, который реализует интерфейс List, должен реализовать эти методы. Конкретные классы реализаций могут также иметь дополнительные методы, а также могут предоставлять различные свойства, такие как возможность изменять размер списка, работать с индексами и т.д.

\section{Итерация по списку}
В Java итерация по списку (List) может быть выполнена с помощью двух основных методов:
Цикл for-each позволяет перебирать элементы списка по очереди, без необходимости вручную управлять индексами. Пример:
    \begin{lstlisting}
        List<String> list = Arrays.asList("one", "two", "three");
for (String element : list) {
    System.out.println(element);
}
    \end{lstlisting}

Итератор - это объект, который позволяет последовательно перебирать элементы списка. Пример:
\begin{lstlisting}
    List<String> list = Arrays.asList("one", "two", "three");
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String element = iterator.next();
    System.out.println(element);
}
\end{lstlisting}
Оба подхода эквивалентны и могут использоваться в зависимости от ситуации. Цикл for-each удобнее использовать, когда вам нужно просто перебрать все элементы списка в порядке их следования. Итератор более гибок, когда нужно выполнить дополнительные операции, такие как удаление элемента во время итерации.
\section{Случайный и последовательный доступ к элементам списка}
Списки (List) в Java позволяют получать доступ к элементам как случайным, так и последовательным образом.

Случайный доступ осуществляется по индексу элемента. Чтобы получить элемент по индексу, нужно вызвать метод get(index). Пример:
\begin{lstlisting}
    List<String> list = Arrays.asList("one", "two", "three");
    String secondElement = list.get(1);
\end{lstlisting}
Последовательный доступ выполняется с помощью итератора или цикла for-each. Итератор позволяет последовательно перебрать все элементы списка. Цикл for-each позволяет обходить элементы списка в том же порядке, в котором они расположены в списке. Примеры:
\begin{lstlisting}
    List<String> list = Arrays.asList("one", "two", "three");

Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String element = iterator.next();
    System.out.println(element);
}

for (String element : list) {
    System.out.println(element);
}
\end{lstlisting}
Выбор между случайным и последовательным доступом зависит от конкретной задачи. Если вам нужно получить доступ к элементам списка в произвольном порядке, используйте случайный доступ. Если вам нужно выполнить последовательный обход элементов списка, используйте итератор или цикл for-each.
\section{Реализация интерфейса List}
Реализация интерфейса List в Java представлена несколькими классами, которые наследуются от абстрактного класса AbstractList:

    ArrayList - реализация динамического массива, который может изменять свой размер при добавлении или удалении элементов.
    LinkedList - реализация связанного списка, где каждый элемент хранит ссылку на предыдущий и следующий элементы.
    Vector - устаревший класс, который представляет динамический массив, похожий на ArrayList, но с синхронизированными методами.
    Stack - также устаревший класс, который наследуется от Vector и представляет стек, где элементы добавляются и удаляются только с одного конца списка.

Каждый из этих классов реализует методы, объявленные в интерфейсе List, и предоставляет различные возможности для работы со списками. Например, ArrayList обеспечивает быстрый доступ к элементам и эффективную вставку и удаление элементов в конец списка, в то время как LinkedList более эффективен при вставке и удалении элементов в середину списка.
\section{Сложность операций}
Сложность операций в реализации интерфейса List зависит от конкретной реализации. В общем случае, следующие операции имеют следующую асимптотическую сложность:

    Добавление элемента в конец списка: О(1) - для ArrayList и LinkedList.
    Вставка элемента в середину списка: O(n) - для ArrayList и O(1) - для LinkedList.
    Удаление элемента из конца списка: О(1) - для ArrayList и LinkedList.
    Удаление элемента из середины списка: O(n) - для ArrayList и O(1) - для LinkedList.
    Доступ к элементу по индексу: О(1) - для ArrayList и O(n) - для LinkedList.

При выборе реализации списка нужно учитывать, какие операции будут чаще выполняться в конкретном приложении, чтобы выбрать подходящую реализацию и достичь наилучшей производительности.

\section{Анализ реализаций ArrayList, LinkedList}
Оба класса - ArrayList и LinkedList - реализуют интерфейс List в Java, но используют различные структуры данных для хранения элементов.

ArrayList хранит элементы в массиве, который расширяется автоматически при необходимости. Это означает, что доступ к элементам осуществляется по индексу и имеет асимптотическую сложность O(1), что делает его эффективным для операций, связанных с доступом по индексу, вставки и удаления элементов в конец списка. Однако при вставке или удалении элементов в середине списка, ArrayList должен перемещать все элементы справа от вставляемого/удаляемого элемента, что может быть дорого с точки зрения производительности, особенно для больших списков.

С другой стороны, LinkedList хранит элементы в виде узлов, каждый из которых содержит ссылки на предыдущий и следующий узлы. Это означает, что доступ к элементам осуществляется путем перебора списка и имеет асимптотическую сложность O(n), что делает его менее эффективным для операций, связанных с доступом по индексу. Однако LinkedList эффективно обрабатывает операции вставки и удаления элементов в середине списка, так как для этого требуется только изменить ссылки на предыдущий и следующий узлы, а не перемещать элементы.

В общем случае, если вы часто выполняете операции доступа по индексу или добавления элементов в конец списка, ArrayList может быть более эффективным выбором. Если же вы часто выполняете операции вставки или удаления элементов в середине списка, LinkedList может быть более эффективным выбором.
%--------------------------------------------------------------------------------------------

\section*{Вопросы и задания для самоконтроля}% Этот раздел будет состоять из вопросов
% и заданий для самоконтроля.
\addcontentsline{toc}{struct}{Вопросы и задания для самоконтроля}% Эта команда
% добавляет название раздела в раздел <<Содержание>>

Здесь можете привести список вопросов и заданий для самоконтроля:
\begin{enumerate}% Эта команда начинает список
\item Вопрос или задание.
\item Вопрос или задание.
\item Вопрос или задание.
\item Вопрос или задание.
\end{enumerate}% Эта команда завершает список

А можете подготовить с помощью программы IrenEditor (см. <<Руководство пользователю>>)
тестовое задание для самоконтроля, сохранить его в папку
<<test>>, назвав, например, lk1.exe, и создать на него метку с помощью
команды (см. <<Руководство пользователю>>): \href{run:test/lk1.exe}{Пройдем тестирование?}
