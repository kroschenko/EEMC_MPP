\newpage % Эта команда начинает новую страницу
\chapter{Тема лекции}% Эта команда начинает первую лекцию. В фигурных скобках нужно
% записать тему лекции. Эта тема лекции автоматически получит порядковый номер и
% автоматически добавится в раздел <<Содержание>>. Лекций можно создавать сколько угодно.
% Для создания новой лекции скопируйте и вставьте (или наберите с клавиатуры) команду
% \chapter{Тема лекции} в любую часть рабочего файла. Можете смело менять местами лекции --
% вся нумерация после очередной компиляции поменяется автоматически.

% При необходимости здесь можно разместить любой текст

\section{Название параграфа}% Эта команда начнет раздел, который будем далее условно называть
% параграф. В роли параграфа будет выступать структурная часть лекции (отдельный раздел,
% вопрос и т.п.). В фигурных скобках нужно вписать название параграфа. Параграф автоматически
% получит порядковый номер, который будет состоять из двух чисел, разделенных точкой.
% Первое число -- порядковый номер лекции, второе число -- порядковый номер параграфа в
% пределах лекции. Параграфов можно создавать сколько угодно. Для создания нового параграфа
% скопируйте и вставьте (или наберите с клавиатуры) команду \section{Название параграфа} в
% любую часть рабочего файла. Можете смело менять местами параграфы, переносить их из одной
% лекции  в другую -- вся нумерация после очередной компиляции поменяется автоматически.

% При необходимости здесь можно разместить любой текст

\subsection{Название подпараграфа}% Эта команда начинает подраздел, который далее будем
% условно называть подпараграфом. В фигурных скобках нужно вписать название подпараграфа.
% Подпараграф автоматически получит порядковый номер, который будет состоять из трех
% чисел, разделенных точками. Первое число -- порядковый номер лекции, второе число --
% порядковый номер параграфа, третье число -- порядковый номер подпараграфа. Подпараграфов
% можно создавать сколько угодно. Для создания нового подпараграфа скопируйте и вставьте
% (или наберите с клавиатуры) команду \subsection{Название подпараграфа} в любую часть
% Рабочего файла. Можете смело менять подпараграфы местами, переносить их из одного
% параграфа в другой (даже другой параграф другой лекции) -- вся нумерация после очередной
% компиляции поменяется автоматически.

Теперь можно приступать к формированию первой лекции Вашего учебно-методического
комплекса. Внимательно прочитайте все рекомендации <<Руководства пользователю>>.

Несколько важных моментов из <<Руководства пользователю>> мы продублируем и здесь.

Начнем с самого главного -- примера оформления программного кода в \LaTeX:

\begin{lstlisting}
    //example of simple java-program
    public class HelloWorld
    {
        public static void main(String[] args)
        {
            int i = 12;
            int a = i + 100;
            System.out.println("Hello, world!");
        }
    }
\end{lstlisting}

Определенные части текста (не содержащие формул, таблиц и иллюстраций -- о них речь пойдет
ниже) могут быть скопированы и вставлены  в рабочий документ из любого
другого текстового редактора. Исходный текст документа не должен содержать переносов
(\LaTeX~ создат их сам). Слова должны отделяться
друг от друга пробелами, но при этом \LaTeX у все-равно, сколько именно пробелов Вы
оставили между
словами, все пробелы \LaTeX~воспримет как один пробел
 (чтобы вручную управлять пробелами между словами можно использовать символ
$\sim$, который называют неразрывным пробелом).
 Конец строки также воспринимается как пробел.
Отдельные абзацы должны быть отделены друг от друга пустыми строками (опять-таки все равно,
сколько именно пустых строк стоит между абзацами, важно, чтобы была хоть одна).

Приведем пример создания определения:

\begin{opr}\label{oprperv} \rm Первообразной функции $f$ на множестве $X{\subset}D(f)$
называется такая функция $F,$ определённая на $X,$ что для любой
точки $x\in{X}$ будет выполняться равенство
  $$F'(x)=f(x).$$
\end{opr}

Пример создания теоремы:
\begin{theorem}\label{theorperv} Если функция $F$ является первообразной для функции $f$
на промежутке $X,$ то:

   {\rm a)} $F(x)+C$ также является первообразной для функции $f$ на промежутке
$X,$ где $C$ --- произвольная действительная постоянная;

    {\rm б)} для любой
другой первообразной $\Phi(x)$ функции $f$ на промежутке $X$
существует такая действительная константа $C,$ что
  $$\Phi(x)=F(x)+C.$$
\end{theorem}

Приведем пример создания гиперссылок на определение \ref{oprperv}  и теорему \ref{theorperv}.

Чтобы научиться легко создавать любые гиперссылки, внимательно прочитайте <<Руководство
пользователю>>.

Теперь приведем пример создания метки {\color{green}\hypertarget{metkatext}{на часть текста}}.

Теперь создадим гиперссылку на словосочетание <<часть текста>>. Пусть эта гиперссылка
состоит из слов <<\hyperlink{metkatext}{текстовая гиперссылка}>>

Пример создания списка:
\begin{enumerate}
\item текст;
\item текст;
\item текст.
\end{enumerate}

Пример создания следствия:
\begin{corollary}{\rm(Свойство линейности)}. Если на промежутке $I$ существуют $\int
f_k(x)dx, k=\overline{1,n}$, а $\alpha_k$ --- произвольные
действительные константы, причем хотя бы одна из них отлична от
нуля, то на $I$ существует $$\int\left(\sum_{k=1}^n \alpha_k
f_k(x)\right)dx=\sum_{k=1}^n \alpha_k
\int{f_k(x)dx}.$$\end{corollary}

Пример вставки рисунка 1n.png из папки <<pic>>/<<images>>.
\begin{figure}[h!]\center
  \includegraphics[height=5.11cm,bb=0 0 464 766]{1n.jpg}
   \caption{Тело вращения}\label{ris1}
\end{figure}

Пример вставки гиперссылки на запуск звукового файла 2.wma из папки <<media>>:
Послушаем \href{run:media/2.wma}{музыку}?

Пример вставки гиперссылки на запуск видео файла film.wmv из папки <<media>>:
\href{run:media/film.avi}{видеофильм}?

\section{Справочная информация}

Этот параграф можно назвать как угодно. Мы установим на первую страницу этого параграфа
метку \label{mybutton}, которая является <<мишенью>> Вашей кнопки на интерактивной панели
(описание процесса ее создания смотрите выше в комментариях).
\begin{enumerate}% Эта команда начинает список
\item Важная информация.
\item Очень важная информация.
\end{enumerate}% Эта команда завершает список

Если теперь скомпилировать <<Рабочий файл>>, то запустив электронный
учебник (файл UMK.pdf) и нажав на кнопку <<Ваша кнопка>> на интерактивной
панели, Вы попадете на эту страницу.

%--------------------------------------------------------------------------------------------

\section*{Вопросы и задания для самоконтроля}% Этот раздел будет состоять из вопросов
% и заданий для самоконтроля.
\addcontentsline{toc}{struct}{Вопросы и задания для самоконтроля}% Эта команда
% добавляет название раздела в раздел <<Содержание>>

Здесь можете привести список вопросов и заданий для самоконтроля:
\begin{enumerate}% Эта команда начинает список
\item Вопрос или задание.
\item Вопрос или задание.
\item Вопрос или задание.
\item Вопрос или задание.
\end{enumerate}% Эта команда завершает список

А можете подготовить с помощью программы IrenEditor (см. <<Руководство пользователю>>)
тестовое задание для самоконтроля, сохранить его в папку
<<test>>, назвав, например, lk1.exe, и создать на него метку с помощью
команды (см. <<Руководство пользователю>>): \href{run:test/lk1.exe}{Пройдем тестирование?}


\newpage% Эта команда начинает новую страницу
\chapter{Принципы тестирования программного обеспечения}
\section{Тестирование, его определение и назначение}
Тестирование - это процесс оценки качества продукта или услуги путем проверки ее соответствия заданным требованиям или спецификациям. Цель тестирования заключается в обнаружении дефектов, ошибок или недочетов в продукте или услуге, чтобы улучшить их качество и уменьшить риски для конечного пользователя.

Основное назначение тестирования - это обеспечение качества продукта или услуги, путем проверки его соответствия определенным требованиям. Тестирование также позволяет выявлять ошибки и дефекты в продукте на ранних этапах разработки, что снижает риски и затраты на исправление проблем в более поздние этапы. Кроме того, тестирование способствует улучшению процессов разработки и управления качеством, что помогает повышать эффективность и производительность команды разработчиков.

В целом, тестирование является важным инструментом для обеспечения качества продукта или услуги, повышения удовлетворенности пользователей и уменьшения рисков для бизнеса.
\section{Экономические аспекты тестирования ПО}
Тестирование программного обеспечения (ПО) имеет экономическую значимость для организаций, занимающихся разработкой и поставкой ПО. Вот несколько основных экономических аспектов тестирования ПО:
\begin{itemize}
    \item Снижение затрат на исправление дефектов: раннее выявление дефектов в процессе тестирования может сократить затраты на исправление этих дефектов в более поздних стадиях разработки. Это помогает сократить расходы на разработку ПО и повышает эффективность команды разработчиков.

    \item Повышение качества ПО: тестирование является ключевым инструментом для обеспечения качества ПО. Если ПО содержит множество дефектов, это может привести к отказам, повреждениям данных и другим проблемам, что может вызвать отрицательный эффект на бизнес-процессы клиентов и затраты на техническую поддержку. Тестирование помогает обнаружить дефекты и устранить их до того, как ПО будет запущено в продакшн.

    \item Повышение удовлетворенности клиентов: клиенты, которые получают ПО с меньшим количеством дефектов, обычно более довольны продуктом и, следовательно, склонны продолжать пользоваться этим ПО. Это может привести к более высокой лояльности клиентов, увеличению объемов продаж и улучшению имиджа компании.

    \item Снижение рисков: тестирование помогает выявить проблемы в ПО на ранних этапах разработки, что помогает снизить риски, связанные с проблемами безопасности, утечкой данных и другими проблемами, которые могут негативно сказаться на бизнесе и репутации компании.
\end{itemize}
В целом, тестирование ПО имеет экономическое значение для компаний, занимающихся разработкой и поставкой ПО, так как помогает снизить затраты на исправление дефектов, повысить качество продукта, увеличить удовлетворенность клиентов и снизить риски.
\section{Возможность исчерпывающего тестирования}
Исчерпывающее тестирование (или полное тестирование) - это тестирование, которое предполагает проверку всех возможных вариантов использования, входных данных, состояний и переходов в системе. Однако, в большинстве случаев, исчерпывающее тестирование невозможно.

Причиной невозможности исчерпывающего тестирования является ограниченное время и ресурсы, доступные для тестирования, а также сложность и многовариантность современных систем. Кроме того, количество возможных вариантов использования может быть огромным, что делает исчерпывающее тестирование практически невозможным.

Вместо этого, при тестировании ПО используются различные методы выборочного тестирования, которые позволяют оценить качество системы на основе ограниченного количества тестовых случаев. Один из таких методов - это метод граничных значений (Boundary Value Analysis), который позволяет выбрать тестовые данные, наиболее вероятные для нахождения ошибок в программе. Другой метод - это метод эквивалентных классов (Equivalence Partitioning), который позволяет сократить количество тестовых случаев, выбирая представительные группы тестовых данных.

Таким образом, исчерпывающее тестирование в большинстве случаев невозможно из-за ограничений во времени и ресурсах, доступных для тестирования, а также сложности системы. Вместо этого используются различные методы выборочного тестирования, которые позволяют выбрать наиболее вероятные для обнаружения ошибок тестовые случаи, что позволяет достичь более высокого уровня качества продукта.
\section{Основные методы тестирования программ}
Существует множество методов тестирования программного обеспечения, и выбор конкретных методов зависит от многих факторов, таких как тип и сложность тестируемой системы, требования к ней и доступные ресурсы. Однако, ниже приведены основные методы тестирования ПО:
\begin{itemize}
    \item Метод белого ящика (White box testing): при этом методе тестирования тестирующий имеет доступ к исходному коду программы и использует знание о внутренней структуре программы, чтобы определить, какие тесты нужно провести. Этот метод позволяет более эффективно проверить отдельные части программы, но требует знания языка программирования и понимания работы программы.

    \item Метод черного ящика (Black box testing): при этом методе тестирования тестирующий не имеет доступа к исходному коду программы и использует только внешнее поведение системы, чтобы определить, какие тесты нужно провести. Этот метод позволяет оценить программу с точки зрения пользователя, но может пропустить некоторые ошибки, связанные с внутренней структурой программы.

    \item Метод серого ящика (Gray box testing): этот метод сочетает в себе элементы методов белого и черного ящика. Тестирующий имеет частичный доступ к исходному коду программы и может использовать его знание о внутренней структуре программы вместе с внешним поведением системы, чтобы провести тесты.

    \item Функциональное тестирование (Functional testing): при этом методе тестирования проверяется соответствие функциональных требований программы, т.е. тестируются основные функции программы и их взаимодействие между собой.

    \item Нагрузочное тестирование (Load testing): при этом методе тестирования проверяется работоспособность программы при заданной нагрузке, т.е. проверяется, как программа справляется с большим количеством запросов или пользователей.

    \item Системное тестирование (System testing): при этом методе тестирования проверяется работоспособность всей системы в целом, а не отдельных ее компонентов.

    \item Интеграционное тестирование (Integration testing): при этом методе тестирования проверяется взаимодействие различных компонентов системы между собой.

    \item Автоматизированное тестирование (Automated testing): при этом методе тестирования используются специальные
    \end{itemize}
\section{Важнейшие принципы тестирования ПО}
Существует несколько важных принципов, которые следует соблюдать при тестировании программного обеспечения:
    \begin{itemize}
    \item Комплексность: тестирование должно покрывать все возможные случаи использования программы и все ее функциональные возможности.

    \item Раннее тестирование: тестирование должно начинаться как можно раньше в жизненном цикле разработки программы, чтобы обнаружить и исправить ошибки наиболее эффективно и дешево.

    \item Автоматизация: автоматизация тестирования позволяет повысить эффективность тестирования, ускорить процесс и уменьшить затраты на ручное тестирование.

    \item Полное покрытие тестами: все основные функциональные возможности программы должны быть покрыты тестами.

    \item Тестирование на реальных данных: тестирование должно проводиться на реальных данных, которые могут быть использованы пользователями программы.

    \item Тестирование безопасности: тестирование безопасности должно проводиться на всех этапах разработки программы, чтобы обнаружить и устранить уязвимости и защитить программу от внешних атак.

    \item Повторяемость: тесты должны быть повторяемыми, т.е. при повторном запуске теста должен получаться одинаковый результат.

    \item Следование стандартам: тестирование должно проводиться в соответствии со стандартами и методологиями, которые приняты в компании или отрасли.

    \item Отчетность: результаты тестирования должны быть документированы и отчеты должны быть доступны для заинтересованных сторон, таких как разработчики, менеджеры проекта и заказчики.

    \item Активное участие всех участников процесса: тестирование является ответственностью всей команды разработки ПО, включая менеджеров проекта, разработчиков и тестировщиков.
    \end{itemize}
